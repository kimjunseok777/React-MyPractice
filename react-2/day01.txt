

리액트의 훅 함수 :

    라이프사이클 (생명주기)  -->  라이프사이클은 웹 페이지 시작되었을 때부터 끝날 때까지 일어나는 이벤트 등을 다루기 위함

    이 라이프사이클이란 친구는 원래 React 16.8 보다 이전 세대인 "클래스형 컴포넌트" 에서 사용하던 말이다
    (React 16.8 보다 이전 버전은 지금처럼 자바스크립트의 함수같은 것이 아니라, JAVA 에 가까웠다  -->  "클래스" 를 사용했었다  -->  "함수" 의 형태가 아니었다)

    meta 팀에서 고민  -->  사용법이 너무 어려움  -->  우리 이거 "함수형" 으로 바꿀까?  -->  이때부터 "함수형 컴포넌트" 시대 (16.8.0 버전부터)
    클래스 컴포넌트가 갖고 있던 "라이프 사이클" 이라고 하는 것을 함수형 컴포넌트에서도 사용할 수 있도록 한 것이 "훅 함수" 이다

    --> 함수형 컴포넌트에서 컴포넌트가 사용자에게 보일 때부터 보이지 않을 때까지 발생할 수 있는 이벤트를 다루는 함수
    ( 마운트  -->  언마운트 )

    - 마운트 : 페이지가 열렸다
    - 언마운트 : 페이지가 사라졌다

    대표적인 친구들 : useState , useRef , useEffect , useMemo , useCallback
                                -->  (useMemo, useCallback 는 바뀔 수도 있다  ->  자동화 될 수도 있음, 사용법이 바뀔 수도 있음)


    -----------------------------------------------------------------------------------------------------------------------------------------------
    

    1. useState  *중요*
            리액트의 "상태" 를 관리하는 함수  -->  상태를 생성하고 값을 변경할 수 있다

            * 상태 :
                    리액트는 DOM API를 사용할 수는 있지만, 지양하고 있다.
                    돔을 활용하지 않고 "가상돔" 을 활용하다보니 값은 변경 되었지만, 사용자가 보는 화면은 변경되지 않습니다.

                    단, 리액트에서는 개발자가 화면을 다시 그리고 싶을 때 화면을 다시 그릴 수 있다  -->  이것을 가능하게 하는 친구가 바로 "상태" 이다

                    상태란, 리액트에서 "가상돔" 과 실제 사용자들이 보는 "랜더트리의 돔" 을 동기화할 수 있는 캐싱(저장) 되어있는 값
                    리액트는 differ 알고리즘을 통해 이전 컴포넌트의 상태와 현재 컴포넌트의 상태를 비교하여, 만약 상태가 변경되었다면, 변경이 된 함수만 리랜더링 합니다.

                    -->  컴포넌트 내의 상태(리액트가 리랜더링을 위해 만든 변수) 가 바뀌면 컴포넌트를 다시 그린다

                    ==> 즉, "상태" 는 한마디로 하면 "변수" 이다  -->  리액트가 리랜더링을 위해 만든 "변수"
                    
                    * 주의사항  -->  상태는 남발해서는 안된다 (불필요히 화면을 다시 그릴 수 있기 때문에, 상태는 늘 "최소화" 하는 것이 중요하다)
                                       -->  상태는 "캐싱(저장)" 하는 값이기에 코스트가 필요한 일이기에 남발하면 안 된다
                                       
            ---------------------------------------------------------------------------------------------------------------------------------------

                    사용법 ex)
                    const [state, setState] = useState()  -->  배열을 "구조분해할당" 한 것이다
                    
                    const [ 변수명 , set 변수명 ] = useState( 변수의 초기값 )

                    상태의 특징 :

                            값을 마음대로 바꾸지 한다.
                            state = 4  -->  (X) 이렇게 값을 직접적으로 바꾸는 것은 안된다

                            상태는 반드시 "setState 함수" 로만 변경이 가능하다
                            setState(4)  -->  (O)
                            console.log(state)  //  4

                            -->  이거 사용하는 순간 이전 값이랑 다르다면 컴포넌트 리랜더링 합니다


            * 불변성 :
                    let a = 5
                    a = 4
                    a는 5를 제거하고 4를 재할당 (값이 변하는 것이 아니라, 다시 할당하는 것이다)

                    * 하지만 객체(object) 일 때는 문제가 생긴다

                    let object = {
                            a: 4
                    }
                    object.a = 5  -->  이러면 a를 제거하고 다시 할당할까, 아니면 값을 바꿀까?  -->  정답은 a의 값을 바꾼다 (그래서 객체는 const 여도 값을 바꿀 수 있는 것이다)
                    (객체는 "참조값" 이어서 값을 바꾸는 것이 가능하다)

                    a의 값을 바꾼다
                    값을 바꾸는 게 문제가 안된다  ==>  하지만 "리액트" 에서는 문제가 된다 ***

                    상태는 이전 값과 이후 값을 "비교"  -->  하지만 객체는 값을 재할당 하는 것이 아니라, 원래의 값을 바꿔버린다

                    그러면, 객체의 값은 참조 "주소" 일까요 "값" 일까요?  -->  주소  -->  그러면, 리액트가 안에 값이 바뀐 것을 어떻게 알 수 있을까?

                    그래서 "복사본" 을 만들고, 할당을 다시 해줘야만 상태가 변경됩니다.
                    불변성을 지켜야한다  -->  안에 있는 값이 바뀌어서는 안된다  -->  새로 할당 되어야한다 (전과 후의 값을 "비교" 해야 하기 때문이다)

                    ex)
                    const temp_object = {...object}
                    setState(temp_object)  -->  위에 복사본 object 를 만들고, 밑에 setState 안에 넣어야 새로운 값이 형성이 되는 것이다

                    이때 map, filter 같은 친구들이 중요하다
                    -->  이 친구들의 반환값 = 새로운 배열  -->  이 친구들을 사용한 것만으로 복사본이 생성된다

                    ==>  이렇게 "새로운 배열" 을 반환하는 친구들은, 굳이 복사본을 만들 필요가 없다  ex) map, filter ... 등등

                    ==>  그래서 map 이나 filter 같은 친구들을 사용하면, 상태 변경하기가 굉장히 쉬워진다  (고차함수 정말정말 많이 사용한다)


===================================================================================================


** 경로 이동 : day01.txt  -->  use-state.jsx


===================================================================================================


    2. useRef

                리랜더링이 함수를 다시 실행하는 것이다
                function a() {
                        let b = 5;
                        b++;
                }
                a()  //  b=6
                a()  //  b=6

                function Component() {
                        const [forceRender, setForceRender] = useState(false)
                        let b = 5;
                        b++;

                        return <div>{b}
                                <button onClick={()=>b++}> + </button>
                                <button onClick={()=>setForceRender(!forceRender)}> 리랜더 </button>
                        </div>
                }
                -->  화면에 뭐가 보이죠? 6
                -->  + 버튼을 세번 눌렀으면 화면에 뭐가 보일까? b의 값은 9이지만, 6이 보인다

                -->  이게 내가 의도한 건가? 나는 9가 화면에 나왔으면 좋겠어서 + 버튼을 3번 누른건데, 근데 리랜더 될 때마다 변수가 초기화??


                "useRef" 는 리랜더링과 상관 없이 변수의 값을 유지하는 변수

                function Component() {

                        const [forceRender, setForceRender] = useState(false)
                        const b = useRef(5)
                        //--> 리랜더링이 되어도 값을 다시 선언하지 않고 계속 유지한다
                        
                        b.current++;
                        //--> 값에 접근할려면 이렇게 current 속성에 접근해야함

                        return <div>
                                {b}
                                <button onClick={() => b.current++}> + </button>
                                <button onClick={() => setForceRender(!forceRender)}> 리랜더 </button>
                        </div>
                }

                -->  114번째 줄에 콘솔 b 를 찍으면  -->  {current : 6}  -->  console.log(b.current)  //  6
                -->  + 버튼을 3번 눌렀을 때 화면에 보이는 b.current 의 값은?  //  b.current 값 자체는 9지만, 화면에 보이는 것은 6이다
                -->  useRef !== state

                --> + 버튼을 3번 눌렀을 때 리랜더 버튼을 누르면 화면에 보이는 값은?  //  10  (함수를 다시 실행하기에 ++ 후위연산자 한번 더 먹는다)
                                -->  리랜더링 되면 연산도 다시 된다, ++를 다시 한 것  -->  그래서 10이 된다

                결론 :
                        useRef 는 상태가 변경됨에 따라 리랜더링 할 때 변수의 선언을 다시하여 초기화하는데, 이러한 과정을 거치지 않고 값을 유지하고 있는 변수

                        이러한 특징 때문에 DOM 에 접근할 때도 사용할 수 있다
                        리액트에 돔에 반드시 접근하는 경우는 있다  -->  사용 안하는 게 아니라 리액트는 dom 사용을 "지양" 하는 것이다

                        return <div className="junseok"/>

                        document.querySelector(.'junseok').style.color="red"  //  리랜더링 하지 않아도 실제 돔에 접근했기 때문에 수정 된다

                        --> 리랜더링이 발생하면 이 값이 유지될까요?  -->  안된다 (리랜더링 한번이면 초기화 돼버린다)  -->  아, DOM API 사용 최대한 줄일게요...

                        하지만 반드시 사용해야하는 경우는 있다 :
                        input의 value 를 가지고 올 때

                        이때 useRef 의 특성을 이용하여 값을 유지시킬 수 있기 때문에 돔에 접근할 수 있다
                        const inputRef = useRef()
                        <input ref={inputRef}/>

                        inputRef.current.value = ' '
                        inputRef.current.style.color = 'red'

                        -->  이게 가능한 이유는, 리랜더링 되어도 값을 갖고 있기 때문이다
                        -->  따라서 리엑트는 리랜더링 되었을 때 DOM 에 대한 정보가 초기화 되기 때문에 DOM 사용을 지양하는 것, 사용이 불가능한 것이 아니다

                        -->  useRef 는 상태가 아니고, 산태가 바뀌었을 때 유지되는 값이다



    3. useEffect

                외부 효과 (사이드 이펙트)
                페이지의 생명주기 동안 발샐할 수 있는 "외부효과" 를 다룰 수 있는 훅 함수
                --> 나는 a 함수를 실행했을 뿐인데, 특정 요직이 같이 실행된다! (외부 효과)

                * 페이지가 마운트 되었을 때
                * 페이지가 언마운트 되었을 때
                * 특정 상태가 바뀌었을 때 : 상태가 바뀌고 나서 바로 출력하는 것이 안된다

    -------------------

    4. useMemo

                function Component() {
                        let a = 5 + 3  //  8
                        const a = useMemo(() => 5+3, [ ])

                        // 연산  -->  리랜더링이 되었을 때 a 는 8 이 그대로
                        // 5+3 을 다시 굳이 할 필요가 있을까?
                        // useRef 처럼 값을 리랜더링해도 저장하기 위해서 사용하는데
                        // useMemo는 연산의 결과값을 저장

                        // 연산이 오래걸리는 결과가 리랜더링을 해도 같다면, 저장하고 사용하는 것이 훨씬 리랜더링 속도가 빠르기 않을까?

                        // 리랜더링 되어도 5+3 을 실행하지 않고 결괏값인 8이 저장되어있음

                        // useRef 는 값 자체를 저장하기 위해 썼다면, useMemo 는 연산을 저장하기 위해 쓴다 (연산 시간을 감소하기 위해 사용하는 것)

                        return <div>:)</div>
                }


    5. useCallback

                변수도 리랜더링이 되면 다시 선언 된다
                연산도 리랜더링이 되면 다시 연산한다
                함수도 리랜더링이 되면 다시 선언할까?  -->  다시 실행한다

                useCallback은 리랜더링 되어도 함수의 로직이 같다면 다시 선언할 필요가 없다
                
                function Component() {
                        const calculate = useCallback(() => {
                                return 5 + 3
                        }, [])

                        return <div>{calculate}</div>
                }




===================================================================================================


** 경로 이동 : day01.txt  -->  


===================================================================================================

-----------------------------------------------------------------------------------------------------------------------------------------------