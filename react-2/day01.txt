

리액트의 훅 함수 :

    라이프사이클 (생명주기)  -->  라이프사이클은 웹 페이지 시작되었을 때부터 끝날 때까지 일어나는 이벤트 등을 다루기 위함

    이 라이프사이클이란 친구는 원래 React 16.8 보다 이전 세대인 "클래스형 컴포넌트" 에서 사용하던 말이다
    (React 16.8 보다 이전 버전은 지금처럼 자바스크립트의 함수 같은 것이 아니라, JAVA 에 가까웠다  -->  "클래스" 를 사용했었다  -->  "함수" 의 형태가 아니었다)

    meta 팀에서 고민  -->  사용법이 너무 어려움  -->  우리 이거 "함수형" 으로 바꿀까?  -->  이때부터 "함수형 컴포넌트" 시대 (16.8.0 버전부터)
    클래스 컴포넌트가 갖고 있던 "라이프 사이클" 이라고 하는 것을 함수형 컴포넌트에서도 사용할 수 있도록 한 것이 "훅 함수" 이다

    --> 함수형 컴포넌트에서 컴포넌트가 사용자에게 보일 때부터 보이지 않을 때까지 발생할 수 있는 이벤트를 다루는 함수
    ( 마운트  -->  언마운트 )

    - 마운트 : 페이지가 열렸다
    - 언마운트 : 페이지가 사라졌다

    대표적인 친구들 : useState , useRef , useEffect , useMemo , useCallback
                                -->  (useMemo, useCallback 는 바뀔 수도 있다  ->  자동화 될 수도 있음, 사용법이 바뀌거나 사라질 수도 있다)


    -----------------------------------------------------------------------------------------------------------------------------------------------
    

        1. useState

                리액트의 "상태" 를 관리하는 함수  -->  상태를 생성하고 값을 변경할 수 있다

                * 상태 :
                        리액트는 DOM API를 사용할 수는 있지만, 지양하고 있다.
                        돔을 활용하지 않고 "가상돔" 을 활용하다보니 값은 변경 되었지만, 사용자가 보는 화면은 변경되지 않습니다.

                        단, 리액트에서는 개발자가 화면을 다시 그리고 싶을 때 화면을 재랜더링 할 수 있다  -->  이것을 가능하게 하는 친구가 바로 "상태(state)" 이다

                        상태란, 리액트에서 "가상돔" 과 실제 사용자들이 보는 "랜더트리의 돔" 을 동기화할 수 있는 캐싱(저장) 되어있는 값
                        리액트는 differ 알고리즘을 통해 이전 컴포넌트의 상태와 현재 컴포넌트의 상태를 "비교" 하여, 만약 상태가 변경되었다면 변경이 된 함수만 리랜더링 합니다.

                        -->  컴포넌트 내의 상태 (리액트가 리랜더링을 위해 만든 변수) 가 바뀌면 컴포넌트를 다시 그린다

                        ==> 즉, "상태" 는 한마디로 하면 "변수" 이다  -->  리액트가 리랜더링을 위해 만든 "변수" 이다 (이 변수가 바뀌면, 화면을 리랜더링 하는 것)
                        
                        * 주의사항  -->  상태는 남발해서는 안된다 (불필요히 화면을 다시 그릴 수 있기 때문에, 상태는 늘 "최소화" 하는 것이 중요하다)
                                        -->  상태는 "캐싱(저장)" 하는 값이기에 "코스트(비용)" 가 필요한 일이기에 남발하면 안 된다
                                       
                ---------------------------------------------------------------------------------------------------------------------------------------

                    사용법 ex)
                    const [state, setState] = useState()  -->  배열을 "구조분해할당" 한 것이다
                    
                    const [ 변수명 , set 변수명 ] = useState( 변수의 초기값 )

                    -->  두번째로 오는 "set변수명" 은 함수이다  -->  set변수명( ) 은 내가 변경하고 싶은 값을 넣어주면 된다

                    상태의 특징 :

                        값을 마음대로 바꾸지 못한다.
                        state = 4  -->  (X) 이렇게 값을 직접적으로 바꾸는 것은 안된다

                        상태는 반드시 "setState 함수" 로만 변경이 가능하다
                        setState(4)  -->  (O)
                        console.log(state)  //  4

                        -->  이거 사용하는 순간 이전 값이랑 다르다면 컴포넌트 리랜더링 합니다

                ---------------------------------------------------------------------------------------------------------------------------------------

                * 불변성 :
                        let a = 5
                        a = 4
                        a는 5를 제거하고 4를 재할당 (값이 변하는 것이 아니라, 다시 할당하는 것이다)

                        * 하지만 객체(object) 일 때는 문제가 생긴다

                        let object = {
                                a: 4
                        }
                        object.a = 5  -->  이러면 a를 제거하고 다시 할당할까, 아니면 값을 바꿀까?  -->  정답은 a의 값을 재할당하지 않고 바꿔버린다 (그래서 객체는 const 여도 값을 바꿀 수 있는 것이다)
                        (객체는 "참조값" 이어서 값을 바꾸는 것이 가능하다)

                        a의 값을 바꾼다
                        값을 바꾸는 게 문제가 되는 건 아니다  ==>  하지만 "리액트" 에서는 문제가 된다 *** (전과 후의 값을 "비교" 라고 화면을 리랜더링 하기 때문  -->  전의 값이 있어야 "비교" 가 가능하다)

                        상태는 이전 값과 이후 값을 "비교"  -->  하지만 객체는 값을 재할당 하는 것이 아니라, 원래의 값을 바꿔버린다

                        그러면, 객체의 값은 참조 "주소" 일까요 "값" 일까요?  -->  주소  -->  그러면, 리액트가 안에 값이 바뀐 것을 어떻게 알 수 있을까?

                        그래서 "복사본" 을 만들고, 할당을 다시 해줘야만 상태가 변경됩니다.
                        불변성을 지켜야한다  -->  안에 있는 값이 바뀌어서는 안된다  -->  새로 할당 되어야한다 (전과 후의 값을 "비교" 해야 하기 때문이다)

                        ex)
                        const temp_object = {...object}
                        setState(temp_object)  -->  위에 복사본 object 를 만들고, 밑에 setState 안에 넣어야 새로운 값이 형성이 되는 것이다

                        이때 map, filter 같은 친구들이 중요하다
                        -->  이 친구들의 반환값 = 새로운 배열  -->  이 친구들을 사용한 것만으로 복사본이 생성된다

                        ==>  이렇게 "새로운 배열" 을 반환하는 친구들은, 굳이 복사본을 만들 필요가 없다  ex) map, filter ... 등등

                        ==>  그래서 map 이나 filter 같은 친구들을 사용하면, 상태 변경하기가 굉장히 쉬워진다  (고차함수 정말정말 많이 사용한다)


===================================================================================================


** 경로 이동 : day01.txt  -->  use-state.jsx


===================================================================================================


        2. useRef

                useRef 는 리랜더링과 상관 없이 변수의 값을 "유지" 하는 변수

                useRef 를 알려면, 리랜더링은 함수를 다시 실행한다는 것을 알아야한다

                function a() {
                        let b = 5;
                        b++;
                }
                a()  //  b=6
                a()  //  b=6  //-->  함수 안에서 b를 5라고 선언했기 때문에 b는 7이 되지 않는다


                -----------------------------------------------------------------------------------


                function Component() {
                        const [forceRender, setForceRender] = useState(false)
                        let b = 5;
                        b++;

                        return <div>{b}
                                <button onClick={()=>b++}> + </button>
                                <button onClick={()=>setForceRender(!forceRender)}> 리랜더 </button>
                        </div>
                }
                -->  화면에 뭐가 보이죠?  -->  6이 보인다

                -->  + 버튼을 세번 누르면 화면에 뭐가 보일까?  -->  b의 값은 9이지만, 6이 보인다 (상태를 바꾸지 않았기 때문)

                -->  + 버튼을 세번 누르고, 리랜더 버튼을 누르면 화면에 뭐가 보일까?  -->  정답은 6이 보인다  -->  리랜더링이 되면, 이 "Component" 함수 자체가 다시 실행되기 때문이다
                        그래서 b의 값이 6이기에 6이 보인다 (함수가 다시 실행되면서 b가 "let b = 5" 로 초기화 되고 "b++" 연산되소 6으로 초기화 되는 것이다)

                ==>  이게 내가 의도한 것인가?  -->  나는 9가 화면에 나오면 좋겠어서 + 버튼을 3번 누른건데, 리랜더 될 때마다 함수가 다시 실행되니까 변수가 초기화 된다고??...
                ==>  그래서 나온 것이 "useRef" 이다


                -----------------------------------------------------------------------------------


                ** useRef 는 리랜더링과 상관 없이 변수의 값을 "유지" 하는 변수

                function Component() {

                        const [forceRender, setForceRender] = useState(false)  -->  강제로 리랜더링되는 역할을 하려고 선언해준 forceRender 상태 변수

                        const b = useRef(5)  -->  이렇게 선언하면, 리랜더링이 되어도 값을 다시 선언하지 않고 계속 유지한다
                        
                        b.current++;  -->  useRef 는 값에 접근하려면, 이렇게 current 속성에 접근해야함 (이렇게 하면 리랜더링이 될 때마다 b 의 값이 계속 증가하게 되는 것이다)

                        console.log(b)  -->  {current : 6} 이 나온다  -->  그래서 값을 출력받으려면, current 로 접근해야한다
                        console.log(b.current)  -->  6 이 나온다

                        return <div>
                                {b}
                                <button onClick={() => b.current++}> + </button>
                                <button onClick={() => setForceRender(!forceRender)}> 리랜더 </button>  -->  true / false 로 계속 변하기에 강제로 리랜더링 시켜준다
                        </div>
                }

                -->  "b.current++" 코드 밑에 콘솔 b 를 찍으면 뭐가 나올까?  -->  {current : 6}  -->  콘솔도 current 로 접근해야 한다  -->  console.log(b.current)  //  6
                
                -->  + 버튼을 3번 눌렀을 때 화면에 보이는 b.current 의 값은?  //  ** b.current 값 자체는 9지만 ** 화면에 보이는 것은 6이다 (리랜더 버튼 아직 누르지 않았기 때문)
                -->  화면은 안바뀌지만, 값은 9 로 바뀌어있다

                -->  useRef !== state  (useRef 로 만들어진 변수는 상태가 아니다  -->  이 변수가 바뀐다고 해서 화면이 바뀌지 않는다는 것이다)

                --> + 버튼을 3번 누르고 리랜더 버튼을 누르면 화면에 보이는 값은?  //  10  (함수를 다시 실행하기에 ++ 후위연산자 한번 더 먹는다)
                -->  리랜더링 되면 기존의 "b.current++" 연산도 다시 된다  -->  ++를 다시 한 것  -->  그래서 10이 된다

                ==>  리랜더링이 되면 연산도 다시해버리기 때문에 연산 조심해서 써야한다 ***
                ==>  그래서 밖에다가 ++ 같은 연산 같은 거 함부로 하면 안된다  -->  map, 사칙연산 .. 등등 모두 다 마찬가지이다


                -----------------------------------------------------------------------------------
                

                결론 :
                        useRef 는 상태가 변경됨에 따라 리랜더링 할 때 변수의 선언을 다시하여 초기화하는데, 이러한 과정을 거치지 않고 값을 유지하고 있는 변수

                        이러한 특징 때문에 DOM 에 접근할 때도 사용할 수 있다 ***
                        리액트에 돔에 반드시 접근하는 경우는 있다  -->  사용 안하는 게 아니라 리액트는 dom 사용을 "지양" 하는 것이다

                        return <div className="junseok"/>

                        document.querySelector(.'junseok').style.color="red"  //  리랜더링 하지 않아도 "실제 돔" 에 접근했기 때문에 수정 된다

                        -->  여기서 리랜더링이 발생하면 이 값이 유지될까요?  -->  안된다 (리랜더링 한번이면 초기화 돼버린다)  -->  DOM API 접근해봤자, 리랜더링 한번이면 다 초기화 된다
                        -->  DOM API 사용을 지양해야하는 이유이다

                        하지만 반드시 DOM API 를 사용해야하는 경우는 있다 :
                        ex) input의 value 를 가지고 올 때 (form 사용하지 않은 input 도 있을 수 있기 때문)  -->  form 으로 하지 않으면, input 값을 어떻게 가져올까?

                        이때 useRef 의 특성을 이용하여 값을 "유지" 시킬 수 있기 때문에 돔에 접근할 수 있다
                        const inputRef = useRef()
                        <input ref={inputRef}/>

                        inputRef.current.value = ' '
                        inputRef.current.style.color = 'red'  -->  이렇게 하면 이 값이 유지가 된다

                        -->  이게 가능한 이유는, 리랜더링 되어도 inputRef 는 값을 갖고 있기 때문이다
                        -->  따라서 리엑트는 리랜더링 되었을 때 DOM 에 대한 정보가 초기화 되기 때문에 DOM 사용을 지양하는 것, 사용이 불가능한 것이 아니다

                        -->  DOM 에 반드시 접근해야할 필요가 있다면, DOM API 사용하지 말고 useRef 사용해라

                        -->  useRef 는 상태가 아니고, 상태가 바뀌었을 때 유지되는 값이다


===================================================================================================


** 경로 이동 : day01.txt  -->  use-ref.jsx


===================================================================================================


        3. useEffect

                useEffect 는 외부 효과이다 (사이드 이펙트)

                페이지의 생명주기 동안 발샐할 수 있는 "외부효과" 를 다룰 수 있는 훅 함수

                * 페이지가 마운트 되었을 때 (눈 앞에 어떠한 창이 나타났을 때)  -->  눈에 보인다면, 마운트 되었다고 할 수 있다

                * 페이지가 언마운트 되었을 때 (눈 앞에서 어떠한 페이지가 사라졌을 때)

                * 특정 상태가 바뀌었을 때  -->  상태가 바뀌고 나서 바로 출력하는 것이 안되기 때문
                   (리랜더링이 되어야만 실행해야 되는데, 이 상태 바뀐 값이 나는 필요해  -->  이럴 때는 무조건 useEffect 를 써야한다)

                ex)
                        use-state.jsx 에서 state 를 바뀌었는데, 이 state 가  " 바뀌고 나서 "  실행해야 하는 요직이 있다면 어떻게해야할까?
                        -->  이럴 때 무조건 useEffect 가 쓰이는 것이다
                        -->  비동기라서 코드블럭 안에 적을 수 없기에, 이 후에 요직을 쓸 때는 useEffect 를 써야하는 것이다

                ex)
                        -->  A 함수를 실행했을 뿐인데, 특정 요직이 같이 실행된다  (사이드 이펙트)
                        -->  A 를 실행했는데 B 가 실행된다  (사이드 이펙트)
                        -->  페이지가 열렸을 뿐인데 useEffect 가 실행된다  (사이트 이펙트)
                        -->  특정 값을 바꿧는데 useEffect 가 실행된다  (사이드 이펙트)

                        ==>  이런 것들을 "사이드 이펙트" 라고 한다

                -----------------------------------------------------------------------------------

                사용법 :
                useEffect(() => {}, [])  -->  마지막에 오는 배열은 "의존성 배열" 이다

                * 의존성 배열 : useEffect 의 callback 함수가 다시 시작하는 기준이 되는 값이다
                
                -->  빈 배열일 때는 페이지가 마운트 되었을 때 최초 1회만 실행한다
                -->  배열의 값이 있다면, 마운트 되었을 때 1회 실행하고, 배열의 값이 바뀔 때마다 실행한다 (배열에 있는 상태의 값이 바뀌어도 실행하는 것이다)


===================================================================================================


** 경로 이동 : day01.txt  -->  use-effect.jsx

        --> 추가로 modal-effect.jsx 에서 ModalEffect 컴포넌트 만들어주자


===================================================================================================


        4. useMemo

                useRef 가 값을 저장 (유지) 했다면, useMemo 는 "연산" 의 결과값을 저장한다

                ex)
                function Component() {
                        let a = 5 + 3  //  8

                        -->  연산  -->  리랜더링이 되었을 때 a 는 8 이 그대로이다  -->  5+3 을 굳이 이 연산을 다시 할 필요가 있을까?

                        -->  useRef 처럼 값을 리랜더링 해도 저장하기 위해서 사용하는데, useMemo는 "연산" 의 결과값을 저장한다

                        -->  연산이 오래걸리는 결과가 리랜더링을 해도 같다면, 저장하고 사용하는 것이 훨씬 리랜더링 속도가 빠르기 않을까?

                        ==>  즉, 연산이 오래걸리는데, 리랜더링해도 결과가 같을 때 "useMemo" 를 사용한다

                        -----------------------------------------------------------------------------------------------------------

                        사용법 :
                        const a = useMemo(() => return 5 + 3, [ ])

                        -->  return 하는 연산된 값을 반환한다

                        -->  이렇게 하면 리랜더링 되어도 5+3 을 다시 실행하지 않고 결괏값인 8이 저장되어있음

                        -->  useRef 는 "값" 자체를 저장하기 위해 썼다면, useMemo 는 "연산된 결과의 값" 을 저장하기 위해 쓴다 (연산 시간을 감소하기 위해 사용하는 것)
                }


===================================================================================================


** 경로 이동 : day01.txt  -->  use-memo.jsx


===================================================================================================


        5. useCallback

                "변수" 도 리랜더링이 되면 다시 선언 된다
                "연산" 도 리랜더링이 되면 다시 연산 한다
                "함수" 도 리랜더링이 되면 다시 선언 할까?  -->  다시 선언한다

                useCallback은 리랜더링 되어도 함수의 로직이 같다면 다시 선언할 필요가 없다
                
                ex)
                        function Component() {
                                const calculate = () => {
                                        return 5 + 3   -->   리랜더링 되어도 결과값 8이 그대로이다  -->  결과 값이 같기 때문에 다시 선언할 필요가 없다
                                }
                                return <div> {calculate} </div>
                        }
                ex)
                        function Component() {
                                const calculate = useCallback(() => {
                                        return 5 + 3   -->   이렇게 useCallback 으로 감싸주면 된다
                                }, [ ])
                                return <div> {calculate} </div>
                        }

                        ==>  보통은 axios 로 콜을 하거나, 다른 컴포넌트로 전달하거나, useEffect 안에 들어가는 함수가 있을 때는 "useCallback" 을 많이 쓴다

                        ==>  즉, 다른 데로 전달되는 함수들이나, axios 나, 요직이 큰 함수들은 "useCallback" 을 많이 쓴다

                        ==>  for 문이 중첩될 때, axios instance 요청해야 할 때, useEffect 에 이 함수를 실행해야할 때,
                                 함수를 props로 전달해서 자식 컴포넌트로 전달할 때 ... 등등 이럴 때 "useCallback" 을 자주 사용한다  +  div 를 return 해야할 때

                        ==>  연산 2회 이상할 때 자주 씀 (중첩 for 문, fetch, useEffect, 다른 컴포넌트에 전달하는 함수 ... 등등 정의해서 사용한다)


===================================================================================================


** 경로 이동 : day01.txt  -->  use-callback.jsx


===================================================================================================
