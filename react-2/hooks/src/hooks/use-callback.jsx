import { useCallback, useEffect, useState } from "react"

const UseCallback = () => {

    // const count = 1
    const [count, setCount] = useState(1)

    //------------------------------------------------------------

    // const onInit = () => {
    //     console.log(5 + count)
    // }

    // 이렇게 useEffect 에 들어가는 함수를 선언해줬는데, 일반 함수로 선언해주는 것이 아니라,
    // 밑에 있는 "useCallback" 으로 함수를 선언해줘야 한다

    //------------------------------------------------------------

    // 의존성 배열 사용 X :

    // const onInit = useCallback(() => {
    //     console.log(5 + count)
    // }, [count])

    //------------------------------------------------------------

    // useEffect 에 특정 함수를 넣어야한다면 "useCallback" 으로 선언해주는 것이 좋다
    /*
        useCallback 우리들 눈앞에 보인다고 하는 것은 사실 어려운 애기이다
        왜냐면 함수가 선언됐다고, 다시 선언됐다고 하는 것을 보여줄 수 없기 때문이다.
        가장 쉽게 볼 수 있는 방법이 하나 있다

        -->  onInit 을 버튼을 눌렀을 때도 실행하게끔 해볼 것이다

        -->  콘솔에 6 이 뜨면 잘 뜨는 것이다  -->  useCallback 으로 전달한 이 함수가 다시 선언되지 않는다라는 것을 보여줄 것이다
        -->  버튼 하나 더 만들어서 count 의 값을 늘려볼 것이다

        -->  + 버튼으로 count 값을 늘리면 리랜더링 됐고, 다시 선언됐다면 count 값이 늘어났으니가 6이 찍히면 안된다  -->  7, 8, 9, 10... 늘어나야 된다
        -->  하지만 + 버튼을 몇번 누르고 실행 버튼을 눌러도 6이 찍힌다  --> count 가 늘어난 상태고 실행을 눌러도 계속 "6" 이 찍힌다

        ==>  이 함수는 처음에 count 가 "1" 이었을 때의 값을 그대로 기억하고 있는 것이다  ==>  즉 이함수에서 count 는 계속 "1" 인 것이다
        ==>  값을 저장하고 있다가, 다시 선언하지 않았다는 얘기이다
        ==>  count 가 늘어나도 값이 계속 1이다  ==>  5 + 1 인 값이 계속해서 나오는 것이다  ==>  "의존성 배열" 에 값을 넣어주면 이러지 않는다

        -->  "의존성 배열" 에 count 를 넣어주면, 다른 변수 (상태) 가 아니라 count 가 늘어났을 때는 다시 연산하게 만들 수 있다
        ==>  이제 count 가 늘어난 값도 적용되면서 실행 버튼을 누르면 원하는 값이 나오게 되는 것이다

        ==>  위에 의존성 배열 사용 안한 것 주석하고, 밑에 있는 의존성 배열 사용한 것을 주석 풀어주고 확인해보자
    */

    //------------------------------------------------------------

    // 의존성 배열 사용 O :

    const onInit = useCallback(() => {
        console.log(5 + count)
    }, [count])  //-->  의존성 배열에 count 를 넣어주면, count 값이 바뀔 때마다 다시 선언한다

    //------------------------------------------------------------

    useEffect(() => onInit(), [onInit])
    // useEffect 처럼 의존성 배열에 함수가 들어가야되는 경우에는 "useCallback" 으로 만들어주는 것이 훨씬 좋다
    //-->  계속 콘솔 찍히는 이유는 이 useEffect 때문에 찍히는 것이다  -->  count 가 바뀌는 것이 onInit 이 바뀌는 것이기에, onInit 이 재실행되면서 콘솔 찍히는 것

    //==>  이거 useEffect 주석처리 해주면 콘솔 계속 찍히지 않는다 (useEffect 가 연쇄적으로 실행되고 있는것  -->  사이드 이펙트)

    return <div>
        :)
        {count}
        <button onClick={() => setCount(count + 1)}>+</button>
        <button onClick={onInit}>실행</button>
    </div>
}
export default UseCallback