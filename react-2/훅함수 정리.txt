

- useState

        상태를 "생성" 하고, set변수명 함수로 상태를 "변경" 할 수 있다  -->  상태가 변경되면 화면을 리랜더링 한다

        ) 상태 :  리액트가 리랜더링을 위해 만든 "변수"  -->  이 변수가 바뀌면 화면을 리랜더링 한다
                     리액트에서 "가상돔" 과 실제 사용자들이 보는 "렌더트리 돔" 을 동기화할 수 있게 저장 되어있는 값이다

        ) 사용법 :  const [ 변수명, set 변수명 ] = useState( 변수의 초기값 )

                      -->  두번째 오는 "set 변수명" 은 함수인데, 상태 변수의 값을 바꾸고 싶다면 이 "setState()" 함수를 이용해야 한다

                      -->  이 상태변수에 값을 넣어주면, 어차피 이 값이 바뀔 때마다 바뀐 상태 (값) 를 재랜더링 하기에, 값을 유지해주려고
                              useRef 쓰지 않아도 바뀐 값이 리랜더링 시에도 계속 유지되는 것이다  (바뀐 값이 리랜더링 되기 때문)



---------------------------------------------------------------------------------------------------------------------------------



- useRef

        상태가 바뀌면 화면이 리랜더링 되는데, 리랜더링 되었을 때 값이 재선언 되어서 초기화 되지 않고 유지되는 변수를 만들어 준다
        리랜더링 되면, "컴포넌트 함수" 자체를 재실행 되기 때문에, 컴포넌트 내부에 적어줬던 (선언해줬던) 값들도 다 재 선언 되면서 초기화 된다

        ) 사용법 :  const 변수명 = useRef( 변수의 초기값 )

                        -->  이렇게 선언해줄 값 자체를 useRef 로 감싸주면, 화면이 리랜더링 되어도 이 변수의 값은 초기화되지 않고 유지된다

        ) 사용법 :  input 태그에 ref 속성으로 접근할 수 있다

                        -->  ex) const titleInputRef = useRef()
                                      <input ref={titleInputRef} />

                        -->  마찬가지로, titleInputRef.current.value  -->  이처럼 입력값에 접근할 때도 current 로 접근해야한다

        ) 주의할 점 :  useRef 로 선언해준 변수에 접근할 때는 반드시 "current" 로 접근해야한다
                            --> useRef 로 선언해주면 current 가 key 값인 변수로 되어있기 때문이다
                            --> ex) const b = useRef(5)
                                          console.log(b)  //  { current : 5 }
                                          console.log(b.current)  //  5

        ) 주의할 점 :  useRef 는 "상태" 가 아니다  -->  useRef 로 선언해준 변수의 값이 바뀐다고 해서 리랜더링 되지 않는다는 소리다
                            -->  상태가 변경될 때, 값지 초기화 되지 않고 "유지" 되는 변수일 뿐이다
        


---------------------------------------------------------------------------------------------------------------------------------



- useEffect

        useEffect 는 사이드이펙트 (외부효과) 이다  -->  페이지의 생명주기 동안 발생할 수 있는 "외부효과" 를 다룰 수 있는 훅 함수이다

        *  페이지가 마운트 되었을 때 (눈 앞에 어떠한 창이 나타났을 때)  -->  눈에 보인다면, 마운트 되었다고 할 수 있다

        *  페이지가 언마운트 되었을 때 (눈 앞에서 페이지가 사라졌을 때)

        *  특정 상태가 바뀌었을 때  -->  상태가 바뀌고 나서 바로 출력하는 것이 안되기 때문
            (리랜더링이 되어야만 실행해야 되는데, 이 상태 바뀐 값이 나는 필요해  -->  이럴 때는 무조건 "useEffect" 를 써야한다)

        ) 사용법 :  useEffect( ( ) => { } , [ ] )

                        -->  마지막에 오는 [ 대괄호 ] 는 "의존성 배열" 이다

                        -->  의존성 배열 :  useEffect 의 콜백 함수가 다시 시작하는 기준이 되는 값이다

                        -->  의존성 배열이 비어있으면, 페이지가 마운트 되었을 때 최초 1회만 실행한다 ) 마운트
                        -->  의존성 배열에 값을 넣어주면, 마운트 되었을 때 1회 실행하고, 의존성 배열에 넣어준 값이 바뀔 때마다 실행한다
                        -->  즉, 이 useEffect 의 재실행 유무는 리랜더링과 관련있는 것이 아니라, 의존성 배열에 들어간 값과 관련이 있다

                        -->  "상태" 가 바뀌어서 리랜더링이 일어났을 때, 의존성 배열에 있는 값이 바뀌었으면 이 useEffect 함수를 재실행한다

                        -->  즉, 의존성 배열의 값이 "상태" 가 들어갈 수도 있고, 일반적인 자바스크립트 변수가 들어갈 수도 있다

                        ==>  중요한 건, 상태가 바뀌었을 때 이 배열 안에 들어가있는 값이 변했냐, 안변했냐 이다

        ) 사용법 :  return ( ) => { }
        
                        -->  useEffect 의 콜백함수에서 "return" 과 "익명함수" 를 적어주면, 이 return 은 "언마운트" 시에 실행한다 ) 언마운트

        ) ex :  어떤 컴포넌트에서 state 가 바뀌었는데, 이 state 가 바뀌고 나서 실행해야하는 요직이 있다면 어떻게 해야할까?  -->  useEffect
                   -->  비동기라서 코드블럭 내에 적을 수 없기에, 이후에 요직을 쓸 때는 useEffect 를 써야한다

        ) ex :  -->  A 함수를 실행했을 뿐인데, 특정 요직이 같이 실행된다  (사이드 이펙트)
                   -->  페이지가 열렸을 뿐인데 useEffect 가 실행된다  (사이트 이펙트)
                   -->  특정 값을 바꿨을 뿐인데 useEffect 가 실행된다  (사이드 이펙트)



---------------------------------------------------------------------------------------------------------------------------------



- useMemo

        useRef 가 "값" 자체를 저장하고 리랜더링 시에 유지했다면, useMemo 는 "연산된 결과의 값" 을 저장하고 유지한다

        ) 사용법 :  useMemo( ( ) => return 연산 , [ ] )

                        -->  return 에 적었던 "연산된 결과의 값" 을 리랜더링 되어도 저장하고 있다

                        -->  useEffect 와 비슷하다고 생각해서, useEffect 에 return 을 적고 사용해버리면 안된다
                                (useEffect 에서 return 문은 "언마운트" 시에 사용하는 것이라 엄연히 useMemo 와 기능이 다르다)

                        -->  의존성 배열에는 useMemo 를 재실행할 기준이 되는 값이 들어간다
                        -->  리랜더링 시에 의존성 배열의 값이 바뀌어 있다면, useMemo 는 재실행하여 재연산한다

                        -->  리랜더링 되어도 값이 같아 연산을 다시해줄 필요가 없다면 useMemo 훅 함수로 사용하면, 리랜더링 되어도
                                재연산을 하지 않는다  -->  의존성 배열의 값을 기준으로 재실행 (재연산) 한다

                        -->  즉, useEffect 와 마찬가지로 리랜더링 시에 의존성 배열에 들어간 값이 변했냐, 변하지 않았냐가 중요하다

        ) ex :  -->  연산이 오래걸리는데, 리랜더링해도 결과가 같을 때 useMemo 를 사용한다
                   -->  for 중첩문, map.find ... 등등 연산을 두번 이상 해야할 경우 (연산에 deep) 많이 사용한다
                   -->  연산의 덩어리가 커질 경우 useMemo 를 사용한다



---------------------------------------------------------------------------------------------------------------------------------



- useCallback

        변수나 연산이 리랜더링 되면 다시 선언하고 연산되었는데, "함수" 도 마찬가지로 리랜더링 되면 다시 선언된다
        리랜더링 되어도 함수의 로직이 같아서 다시 선언할 필요가 없을 때 useCallback 을 사용한다

        ) 사용법 :  const 함수명 = useCallback( ( ) => { } , [ ] )

                        -->  리랜더링 되었을 때, 함수를 재선언 (재실행) 하지 않는다
                        -->  의존성 배열에 들어간 상태 값이 바뀌었을 때, 함수를 재선언 (실행) 하고 리랜더링 된다
                        -->  의존성 배열에 들어간 상태 변수가 아니면, 다른 상태 변수가 바뀌어
                                리랜더링 되어도 이 useCallback 으로 선언해준 함수는 재선언 되지 않는다

                        -->  useEffect 에 들어가는 함수는 useCallback 으로 선언해주는 것이 좋다

                        -->  어떻게 보면 알반 함수와 같아 보이지만, 함수가 리랜더링 되어도 재선언 하지 않는 것을 확인할 수 있다

        ) ex :  -->  useEffect( ( ) => 함수명(), [ 함수명 ] )  -->  이렇게 useEffect 처럼 의존성 배열로 함수가 들어가는 경우에는, 이 함수를
                                                                                                   useCallback 으로 선언해주는 것이 좋다