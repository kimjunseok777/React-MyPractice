

msw-2 는 투두페이지에서 msw 적용시키는 것부터 시작하는데, 전에 비동기.txt 공부 모두 마치고 시작하자


===================================================================================================


** 경로 이동 : todo.api.js  /  todoList.jsx

        -->  getTodos , addTodo 를 fetch 로 데이터를 불러와서 사용해볼 것이다  -->  조회, 생성 해볼것이다

        -->  데이터를 불러와서 사용하는 페이지는 투두페이지이기에 todoList.jsx 로 이동해주자

        ==>  우리가 만든 todoSlice 에는 조회 (getTodo) 가 없기 때문에 전역상태관리 todoSlice 에 추가해주자 (가상 백엔드에서 todo 데이터 불러올 것이기 때문에 필요하다)


** 경로 이동 : todoList.jsx  -->  todo.slice.js

        -->  reducer 에 getTodos 추가해주자 (백엔드에서 데이터 불러와서 조회하는 기능 만들어줄 것이다  -->  todoList.jsx 에서 fetch 로 투두 데이터 불러와서 사용하면 된다)

        -->  Mocking API 에서 불러운 todo 의 결과값을 전역상태관리 하기 위해서 todoSlice 의 reducers 에 getTodos 를 추가하고
                기본 값이었던 todo (initialState) 를 빈 배열로 만들어줬다  -->  이제 백엔드에서 불러올거니까 필요 없기 때문이다

        ==>  jsDocs 도 함께 공부해보자 (협업할 때 중요하다)
        ==>  createSlice 도 마우스 대보면 설명 달아져있는 것을 확인할 수 있다 (다 jsDocs 사용해서 설명을 추가해준 것이다)
        ==> addTodo.jsx 가서 jsDocs 한번 달아보자


===================================================================================================


** 경로 이동 : todo.slice.js  -->  todoList.jsx

        -->  todo 페이지가 로드 되었을 때, 서버에 요청을 하여 todo 를 불러오고, dispatch 를 통해 해당 todo 데이터를 reducer 로 전송할 것이다
                페이지가 로드되었을 때라면, useEffect 사용하면 된다


** 경로 이동 : todoList.jsx  -->  handler.js

        -->  todo.api.js 에서 만든 것 import 받아서 등록시켜주자
        -->  등록 시켜주지 않으면 가상으로 만든 백엔드서버 ("/api/tood") 가 없기 때문에 fetch 를 쓰면 프론트 서버에 요청한다  -->  이러면 html 을 반환한다


===================================================================================================


** 경로 이동 : handler.js  -->  App.js

        -->  msw 도 실행하는데 시간이 걸린다

        -->  msw 가 실행이 되기 전에 useEffect 를 콜해버린다  -->  Mocking Api 가 만들어지지도 않았는데, 백엔드에게 요청하게 되버릴 수도 있는 것이다
                이러면 새로고침해도 수정이 안되는 이슈가 생긴다

        -->  msw 를 실행시키는 요직을 만들어줘야한다
        
        ex) 새로고침 했을 때 상태를 만들어주고, 그 상태가 바뀌었다면 msw 를 실행하고 다시 리랜더를 다시 시켜주는 방법밖에 없다
                (강제 리랜더를 시키는 것인데, 좋은 방법은 절대 아니다)

                -->  async 함수와 리랜더 됐을 때 server.start 하는 useEffect 만들어주자


===================================================================================================


** 경로 이동 : App.js  -->  index.js

        -->  앞에서 App.js 에서 작성해줬던 코드들 다 지우고, index.js 에서 다시 작성해줬다

        -->  server.start() 로 msw 가 실행되고 난 후에, 랜더링이될 수 있도록 만들어준 것이다

        -->  msw 가 실행될 때까지 코드를 안보여주는 요직을 만든 것이다 (Mock 데이터가 모두 만들어져야, 실행되야 다음 코드가 실행하는 것이다)

        ==>  원래는 index.js 는 건들면 안되는데, msw 가 업데이트 되면서 서버가 시작될 때까지 기다려주지 않으면, useEffect 가 먼저 실행이 되버린다
                그래서 이부분을 고치기위해서 index.js 를 바꿔준 것이다 (리액트 구조 자체를 바꿔준 것)

        ==>  msw 가 init 되는 것을 기다린 후에 server.start 를 하고, render 를 하는 형태로 바꿔준 것이다

        ==>  이렇게 수정하면 이제 로그인에서 투두페이지로 이동을 했든, 화면 새로고침을 했든 화면이 기능 작성한대로 잘 나온다

        ==>  msw 가 2.0 으로 버전이 바뀌면서 실행되는 코드가 동기가 아닌 비동기로 바뀌었다  -->  그래서 사전에 await 으로 기다려주고 사용한 것이다


===================================================================================================


** 경로 이동 : index.js  -->  addTodoModal.jsx

        -->  투두 추가하는 것 fetch 와 dispatch 사용해서 만들어볼 것이다

        -->  todo.api.js 확인해보면 추가하기는 request 로 필요한 값이 title 과 content 이다

        -->  dispatch 안에, 즉, payload 객체로 가상 백엔드에서 응답받은 데이터를 넣으면 되는 것이다  -->  todo.pai.js / todo.slice.js 함께 확인해보자

        -->  logger 도 데이터가 잘 전달됐는지 같이 확인해보자

        ) update 와 delete 는 과제이다


===================================================================================================


==>  웹사이트를 볼 때, 백엔드에서 받아온 데이터인지 확인하는 방법은, 화면이 동적으로 변할 가능성이 있는지를 확인하면 된다
        ex) 인기차트, 순위, 최신상품, 실시간 검색 순위, 인기상품 ... 등등

==>  백엔드에 내가 어떤 데이터를 보내야 되고, 어떤 데이터를 받아올지 예측하는 능력을 기르는 것이 매우매우 중요하다  ***

==>  msw 를 잘쓰고 싶다면 백엔드의 input 과 output 을 예측하는 것이 매우 중요하다  ***


===================================================================================================

이제 redux thunk 를 사용해볼 것이다

===================================================================================================


** 경로 이동 : todo.slice.js

        -->  이때까지 todo 배열에 변화를 주면서 진행해봤는데, todo 는 실패할 수도 있고 성공할 수도 있다 (백엔드에 대한 요청은 성공할 수도 있고 실패할 수도 있다)

        -->  사용자들은 투두가 추가되는데 시간이 1초 이상 걸린다면, 아마 추가 버튼을 연속으로 누를 것이다
                즉, 투두리스트가 로딩중 이라는 상태를 보여줄 의무가 있다

        -->  initialState 에 addTodoState 추가해주자

        ==>  redux saga / thunk : 백엔드에 대한 요청을 도와줄 미들웨어이다

        ==>  createSlice 에서 extraReducers 추가해주자 (그냥 reducers 에서 사용하면 안된다)

        -->  reducers 에 만든 addTodo 지워주고 extraReducers 에 새로 만들어주자

        -->  export 해줄 때 { createAsyncThunk } import 받아서 사용해줬다


===================================================================================================


** 경로 이동 : todo.slice.js  -->  addTodoModal.jsx

        -->  addTodo 에서 redux thunk 사용해주자

        -->  전에 적었던 const result 이거 싹다 지워주고 thunk 로 만들어주 addTodo 불러와서 사용해주자
                ex) const result = await fetch("/api/todo", { ... } )  -->  이거 삭제해주자
                ex) dispatch(addTodo(
                        { title : ... , content : ... }
                ))
                -->  이렇게만 보내주면 끝난다

        -->  setIsOpenAddTodoModal(false) 사용한 것 함수 아래에 useEffect 로 바꿔주자 (done 활용한 것)

        -->  return 하는 컴포넌트 부분도 약간 수정했으니 함께 확인해보자

        ==>  로딩 등의 여부에 따라서 사용자들에게 다양한 UI 를 보여줄 의무가 있다

        ==>  사용자한테 로딩이나 에러에 따른 다른 UI 를 보여주는 것이 redux thunk 이다


===================================================================================================


) 과제 :

        1. updateTodo, deleteTodo  -->  msw 로 생성해서 백엔드에게 가상 요청하기

        2. getTodos 만 createAsyncThunk 하여 로딩중인 상태 UI 만들기 (아마 너무 빨라서 안보일 것이다  -->  콘솔로만 찍어보기)

                -->  TodoList return if(state.getTodo.loading) return <div>Loading...</div>  -->  대충 이런식으로
        