

이렇게 rtk 의 DevTools 까지 마쳤으면, 이제 msw 해볼 것이다 (가상으로 백엔드 데이터를 만드는 것)

msw (Mocking API)  -->  가상의 백엔드 API 를 만들고 Mocking 하는 것이다

        ) 장점 : 백엔드와 프론트엔드 개발자가 동시에 개발을 시작했다고 가정해보자
                    프론트엔드 개발자가 퍼블리싱 하고 있을 때, 백엔드 API 가 나왔을 수도 있고, 아직 나오지 않았을 수도 있다

                    -->  이때 백엔드 API 가 아직 나오지 않았다고 프론트 개발자가 작업을 멈춰있으면 안된다
                    -->  프론트엔드 개발자는 백엔드 api 를 가상으로 만들어 개발을 이어나갸아한다

                    ==>  백엔드가 없이도 가상의 api (Mocking) 를 만들어서 개발을 할 수 있다  -->  axios, fetch 이런 친구들도 쓸 수 있다

                    ==>  실제 백엔드에 요청하지 않아도 실제 테스크 코드나 테스크 시나리오를 작성할 수 있다  ==>  백엔드가 있어야 할 수 있는 걸, 없이도 테스트해 볼 수 있다
                             (실제 백엔드에 요청하지 않고도 프론트엔드가 정상적으로 작동하는지 확인이 가능하다  -->  가상으로 백엔드에서 올 데이터를 만드는 것이다)

        ) 그렇다면, 왜 실제 백엔드에 요청하면 안될까?

                1. 프론트엔드는 백엔드와 상관 없이 언제든 정상적으로 작동해야한다  -->  백엔드에서 에러가 나든 안나든 프론트는 정상적으로 작동해야한다

                2. 다양한 시나리오 분석이 가능하다  -->  실패할 경우의 요청같은 것들도 마음대로 컨트롤 할 수 있다 (실패하는 API 를 만들 수도 있는 것이다)

                3. 백엔드가 인터넷이나 오류로 작동하지 않을 때 프론트가 테스트를 못해보는 경우가 없다
                        ex) 백엔드가 인터넷이 느리거나 서버가 터졌다  -->  그렇다고 프론트엔드 부분이 막히면 안된다 (테스트를 못하는 경우가 없어야한다)
                                -->  Mocking 으로 가상의 api 를 만들어서 테스트하거나, 테스크를 진행하는 경우가 많다  -->  보통 프론트 작업 속도가 더 빠르기 때문에 msw 가 필요하다

        ==>  이러한 이유들 때문에 "msw" 를 공부해야한다
        ==>  사용하는 가장 궁극적인 이유는, 백엔드와 상관없이 프론트에 있는 모든 코드를 진행해볼 수 있도록 하기 위해 msw 로 작업을 진행하는 것이다
        
        이제 msw 로 Mocking API 를 만들것이다  -->  이 Mocking API 활용해서, redux 의 thunk 를 만들어볼 것이다


===================================================================================================


) 테스트 코드 :

        ex) A라는 기능을 개발했는데, B라는 기능에 이슈가 생길 수도 있다  -->  내가 개발을 할 때마다 처음부터 끝까지 정상 작동하는지 직접 확인해야한다

        -->  이렇게 매번 직접 확인하면 코스트가 발생, 즉 HR 이 발생한다  -->  사람보다 기계로 테스트하는 것이 훨씬 저렴하고 속도가 빠르다

        -->  내가 개발한 기능을 테스트하는 코드를 작성하는 것이다  -->  "테스트 코드" 라고 한다

        ==>  자바스크립트에서는  "jest"  또는  "vi-text"  라는 것을 많이 사용한다

        ) TDD (Test Driven Development) : 실제 기능을 작성하기 전에 테스트 코드를 먼저 작성하고 기능을 개발하는 것이다  -->  테스트 주도 개발 (driven : ~ 주도의)
                                                                      TDD 방식은 백엔드에서 많이 사용한다

        -->  훨씬 더 코드가 안정성 있게 개발이 된다

        ==>  백엔드는 테스트코드를 엄격하게 작성하는 반면에, 프론트엔드는 테스트 코드를 엄격하게 작성하지 않는다
                  이유는 변경이 많기 때문이다 (UI가 업데이트 되는 등등 변경이 많다)  -->  ex) 배달의 민족 UI 만 봐도, 되게 자주 업데이터되며 UI 가 바뀌는 것을 확인할 수 있다

        ==>  변경이 될 때마다 테스트 코드도 함께 수정해야된다  -->  리소스가 든다 (코스트가 든다)

        ==>  즉, 프론트엔드는 테스트코드를 간단한 모듈 테스트나, e2e 테스트를 진행한다 (처음부터 끝까지 사이트 기능들 마음껏 눌러보는 것)

        ==>  프론트엔드에서 테스트 코드를 작성할 때 "벡엔드에 요청" 을 하게 되면  -->  실제 유저가 회원가입이 되기 때문에 유령 회원이 발생하고
                 또한, 백엔드가 작동하지 않으면 프론트는 테스트 코드를 작성할 수 없다

        ==>  즉, 프론트엔드는 테스트를 할 때, 백엔드에서 API 를 받기 때문에 한계가 발생한다  -->  그래서 나온 것이 "msw" 이다 (Mocking API  -->  가상 API)

        ) msw : 백엔드 API 를 Mocking 하고, 백엔드와 상관없이 프론트엔드를 개발 및 테스트할 수 있다
                      프론트엔드 테스트할 때는 많이 쓰이지만, 그 외에는 많이 쓰이지 않는다

                      ==>  아직 우리가 백엔드가 없기 때문에, msw 라이브러리를 공부하는 것이다 (이거 몰라도 개발하는데는 지장 없다)


===================================================================================================


msw 공식 홈페이지 가서 사용법 확인해보자 (Mocking 라이브러리)

        -->  확인해보면, HttpResponse.json({ id : ~ , title : ~ , ... })  -->  목데이터를 여기서 보내주는 것이다 (이제 가상 데이터 todos 같은 거 만들 필요 없다)

        -->  axios 나 fetch 로 요청하면 이 JSON 데이터가 오는 것이다

        ==>  이 msw 를 사용해서 투두리스트에 적용시켜볼 것이다

        ==>  HttpResponse 와 http 라는 객체만 알고 있으면 진행이 가능하다  -->  모두 "msw" 에서 import 받은 것이다


===================================================================================================


** 경로 이동 : msw-todolist

        -->  공식문서보고 설치해주자 (init 해주고, npm i 과정 진행하면 된다)

        ==>  npm install msw@latest --save-dev
        ==>  npx msw init ./public

        이렇게 npm i 하고 npx 해주면 msw 설치 된다

        -->  "npx msw init ./public" 하면 리액트 패키지의 public 폴더에 mockServiceWorker.js 생긴 것을 확인할 수 있다


===================================================================================================


** 경로 이동 : msw-todolist  -->  mocks  -->  handlers.js

        -->  handlers 배열 안에 가상의 api 들을 넣을 것이다

        ex) export const handlers = [
                        http.get("/todo", () => {  (==>  "/todo" 이 주소에 axios 나 fetch 로 데이터를 요청하면 아래 HttpResponse 에 적은 json 데이터가 오는 것이다
                                                                   (==>  백엔드가 없이도 axios 나 fetch 를 쓸 수 있다 (백엔드에 요청하는 것)
                                return HttpResponse.json({  (==>  여기서 json 형태의 가짜 데이터, 즉, mock 데이터를 여기서 만들고 보내주는 것이다
                                        id: 1,
                                        title : 1,
                                        ...
                                })
                        })
                ]
                ==>  이 배열 안에 들어가는 HttpResponse 데이터들은 user.api.js , todo.api.js 로 따로 빼서 만들어줬다 (각각 UserApi , TodoApi 로 import 받아서 사용해줬음)


===================================================================================================


** 경로 이동 : handlers.js  -->  server.js

        -->  server 만들어주자  -->  공식문서 보고 만들 것이다  -->  handlers 를 "전개연산자" 로 넣어줬다  -->  ex) setupWorker( ...handlers )

        ==>  setupWorker : 브라우저 환경에서 네트워크 요청을 모킹하는 데 사용된다
                                           이를 통해 개발자는 실제 서버와의 통신 없이도 네트워크 요청을 테스트하고 디버깅할 수 있다
                                           
                                           -->  이 setupWorker 에다가 앞에서 만든 목데이터가 들어있는 handlers 를 import 해서 전개연산자로 넣어줬다
                                           -->  그리고 여기서 export 된 것은 최상위 컴포넌트로 가서 사용된다  -->  server.start() 로 msw 를 실행시키는데 사용된다


===================================================================================================


** 경로 이동 : App.js

        -->  공식문서대로, 최상위 컴포넌트 (App.js) 로 가서 "server.listen()" 만들어주자

        -->  여기까지 하면 msw 를 사용하기 위한 기초 준비가 완료된 것이다

        ) 순서정리 :

                1. npm install msw@latest --save-dev

                2. npx msw init ./public

                3. handlers.js , server.js  -->  setupServer 를 setupWorker 로 바꿔줬다 (import 해온 곳도 다르다)

                4. App.js  -->  server.listen()  -->  이거 안돼서 개발자 모드일 때 server.start() 함게끔 바꿔줬다
                                                                    --> ex) if(process.env.NODE_ENV === "development") server.start()

        ==>  server.start() : 이 코드를 최상위 컴포넌트에 작성하면, 이제 서버를 실행하여 네트워크 요청을 가로채기 시작하고, 정의된 핸들러에 따라 응답을 반환한다
                                            --> user.api.js 에서 데이터와 조건들을 정의해줬다

        ==>  콘솔창에 "[MSW] Mocking enabled" 가 뜨면 msw 준비가 잘 된 것이다
        ==>  백엔드 API 를 Mocking 한 것이다  -->  Mocking 했다는 것은, 가상 데이터를 만들었다는 말이다


===================================================================================================


) 로그인, 회원가입 페이지에서 msw 를 사용해볼 것이다 (백엔드에서 받는 API 를 Mocking 해서 실제 백엔드에서 데이터를 받는 것처럼 만들어볼 것이다)

** 경로 이동 : mocks  -->  apis  -->  user.api.js (로그인 먼저 다 만들고, 투두 만들 것이다)

        ==>  get , post 차이를 명확히 이해하고 넘어가자  ***  (데이터를 전송하는 것에 차이가 있다)

        ==>  http.post("/api/user/login")  -->  이 코드 의미 정확히 이해하고 넘어가자  ***  (백엔드가 메소드와 자기 주소를 설정한 것이다)

        ==>  msw 공식문서에서 Migrations 목록 들어가보면 데이터를 어떻게 받아올 수 있는지 확인할 수 있다

        ==>  msw 공식문서 보면서 공부해보자 (async 적은 것도 공식문서 보고 적은 것이다)


        ) Mocking : 실제 서버와의 통신 없이 네트워크 요청을 가로채고 "가짜 데이터" 를 반환하는 것이다
                             이를 통해 프론트엔드는 실제 서버가 준비되지 않았거나, 서버와의 통신이 불안정한 상황에서도 프론트엔드 애플리케이션을 개발하고 테스트할 수 있다


===================================================================================================


** 경로 이동 : user.api.js  -->  handlers.js

        -->  이제 handlers 에서 데이터를 불러올 것이다 (앞에서 만든 로그인 Mock 데이터 넣어줄 것이다)

        -->  ex) handlers = [...Object.values(UserApi)]  -->  왜 전개연산자로 넣어줬을까?


===================================================================================================


** 경로 이동 : handlers.js  -->  sign-in-form.jsx

        ==>  이 부분 매우매우 중요하니까 반드시 전부 다 이해하고 넘어가자

        ==>  fetch 사용하는 부분에서  "async" , "fetch" , "await" , "method" , "body"  정확하게 이해하고 넘어가자

        -->  handlePressSignIn 함수 안에 원래 적었던 요직 (rhf로 적었음) 대신에 실제로 백엔드한테 요청하는 요직을 넣으면 된다
                (로그인에 관한 조건 검사를 msw 로 실제 백엔드에게 데이터 받는 것처럼 바꿔볼 것이다)

        -->  fetch 는 데이터가 string 형태로 오기 때문에, json 으로 바꿔줘야한다  -->  이런거 불편해서 쓰는 것이 axios 이다 (나중에 배운다)

        -->  ex) const response_data = await response.json()  -->  fetch 사용한 response 를 json 으로 바꿔줬다
                        -->  then 으로 해줘도 되지만, async 함수 안에서 사용하는 것이기에 await 으로 해줬다


        ) 여기서 가장 중요한 부분 :

                -->  백엔드에도 "/api/user/login" 와 같은 주소 (프론트에센 데이터 전달하는 목적지) 가 있다

                -->  DataBase 에서 뒤져서 우리 (프론트) 한테 주려는 결과값 데이터를 세팅을 해서 (데이터 가공, 에러처리 ... 등등) 데이터를 프론트한테 전송해주는 것이다

                -->  백엔드 개발자들이 하는 역할을 살짝 이해해보자


===================================================================================================


** 경로 이동 : todo.api.js

        -->  투두페이지도 마찬가지로 백엔드가 있다고 가정하기 위해 Mock 데이터를 만들어주자

        -->  작성, 조회, 수정, 삭제 ... 등등 백엔드에게 요청하기 위한 주소와 목데이터 만들어주자

        -->  새로 "조회" 만들어주는 이유는 투두리스트의 기본 데이터도 목데이터로 만들어서 가상의 API 에서 전달받아야 하기 때문이다

        ==>  이렇게 하면 msw-1 수업 종료


===================================================================================================