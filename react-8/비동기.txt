

) 비동기란 무엇일까?

    -->  동기적 (순서대로 실행) 이지 않은 것을 뜻한다
    -->  비동기 코드는 동기적인 코드가 실행할 때, 같이 실행은 되지면 대기상태 (pending 상태) 가 되면서
            동기적인 코드가 모두 실행되고 난 후에 결과값 (reject, fulfilled ...) 을 반환한다 (성공 or 실패)
            (이벤트루프의 "que" 라는 저장소에 저장되어 대기하고 있다  -->  "콜스택" 으로 올라와서 실행이 된다)

    ==>  즉, 비동기는 동기와 같이 실행되는데, 동기적인 코드 모두 끝나고 결과를 반환한다


) 이벤트 루프 흐름:

        동기적인 코드들은 "콜스택" 에 저장이 되고 실행된다  -->  하지만 비동기적 코드들은 콜스택이 아닌 "WebAPIs" 로 이동하고 여기서 실행된다
        -->  그리고 결과는 "콜백큐" 로 이동을 한다  -->  "콜백큐" 에서는 콜스택에 있는 동기적 코드들이 모두 실행된 것이 확인되면 비동기적 코드들의 결과를 반환한다

----------------------------------------------------------------------------------------------------------------------------------------

) 비동기는 왜 등장했는가?

    -->  자바스크립트는 싱글 스레드이다  -->  코드를 처리할 수 있는 일꾼이 딱 1명이다 (싱글 스레드)
    -->  자바스크립트는 일꾼이 하나니까, 여러 일을 동시에 해결하기 위해서 "비동기" 가 나오게 된 것이다

    ex)
    코드를 진행하는데 A -> B -> C -> D 라고 하는 함수들이 있다고 해보자

    A (1초)  -->  B (1초)  -->  C (3초)  -->  D (1초)  ==>  모두 실행하는데 6초가 걸린다

    A, B, D 를 실행하는 동안, C 를 함께 실행할 수 있다고 한다면 몇초가 걸릴까?  ==>  3초가 걸린다

    즉, 비동기라고 하는 것은 자바스크립트에서 시간이 많이 소요될 수 있는 함수들을 따로 빼서 (이벤트루프에 넘긴다  -->  WebAPIs 로 이동) 따로 실행하는 것이다
    -->  동기적인 코드와 비동기적인 코드를 같이 실행시킬 수 있는 것이다  -->  시간을 감소시킬 수 있다 (먼저 화면에 보이는 것은 동깆적인 코드이다)
    ==>  같이 실행은 하되, 비동기 코드들은, 동기 코드들이 모두 끝나야만 결과를 반환하는 것이다 (어쨌든 실행은 같이 한다)

----------------------------------------------------------------------------------------------------------------------------------------

) 프론트엔드 개발자가 가장 많이 만나는 비동기해야하는 상황은 언제일까?
    
    1. 백엔드에서 데이터 받아올 때  -->  가장 많은 비중을 차지한다  ***
    2. 특정 시간 이후에 실행해야할 때  -->  ex) setTimeout, setInterval ... 등등
    3. 동기적인 코드가 모두 실행되고 나서 실행해야할 때

    fetch 또는 axios 가 대표적으로 백엔드와 데이터 통신을 할 때 가장 많이 사용하는 도구이다  ***
    -->  fetch, axios 는 비동기 처리가 된다  -->  동기적인 코드들이 실행될 때 같이 실행하고, 동기적인 코드가 모두 끝나면 결과를 실행한다

----------------------------------------------------------------------------------------------------------------------------------------

) 비동기 처리

    ex)
    A (1초)  -->  B (1초)  -->  C (3초 - 비동기)  -->  D (1초)  -->  E (1초)
    ==>  모두 실행되려면 몇초가 걸릴까?  -->  4초가 걸린다

    ==>  하지만, 동기적 함수이지만, 실행하기 위해 비동기 함수의 실행이 필요하다면 어떻게 될까?

    ex)
    A (1초)  -->  B (1초)  -->  C (3초 - 비동기)  -->  D (1초)  -->  E (1초)  -->  F (1초 - C가 필요하다)
    ==>  F 가 실행되려면 비동기인 C 가 필요하다
             C 가 밑으로 이동했다고 해보자 (비동기기에 같이 실행하니 보기 편하게 밑으로 이동시켜보자)

    A (1초)  -->  B (1초)  -->  D (1초)  -->  E (1초)  -->  F (1초 - C가 필요하다)
    C (3초) -----------------------// C는 이때 실행이 끝난다  -->  이때 F는 C의 결과값을 사용할 수 있을까?  -->  사용할 수 없다, 에러뜬다

    ==>  비동기는 동기적 코드가 모두 실행되고 나서 실행되기에, C의 결과값은 F까지 끝나고 실행된다  -->  즉, F는 없다 (C 없기 때문에 오류뜬다)
    ==>  그래서 나오게 된 것이 Promise 와 async, await 이다  -->  C 와 F 를 한세트로 묶을 수 있다 (비동기 처리해주는 것이다)

    ex)
    A (1초)  -->  B (1초)  -->  D (1초)  -->  E (1초)  ==>  실행하는데 4초가 걸린다 (동기적 코드 실행에 C가 필요하지 않기 때문에 에러가 나지 않는다)
    C (3초)  -->  F (1초)  ==>  A, B, D, E 가 끝나면 C 와 F 을 결과를 함께 보여준다 (F를 비동기 처리 해준 것이다)
    ==>  이렇게 동기 함수와 비동기 함수를 묶어서 사용할 수 있다 (C랑 F를 함께 비동기로 만들어버린 것이다)

----------------------------------------------------------------------------------------------------------------------------------------

) 대표적인 비동기처리 : promise , async / await

    -->  비동기가 아니지만, 비동기 다음에 실행해야 되는 친구들도 함께 비동기로 만들어줄 수 있다 (동기적인 코드를 비동기로 바꿔줄 수 있는 것이다)

--------------------------------------------------------------------------

) promise

    ex)
    new Promise(( reject, resolve ) => {
        //-->  reject 에다가 결과값이 반환되면 "catch" 로 이동하고, resolve 에다가 결과값이 반환되면 "then" 으로 이동한다 (콜백함수의 매개변수로 들어간다)
        // then  ->  이행 (resolve)
        // catch  ->  실패 (reject)

        C  -->  C 는 실패할 수도 있고 성공할 수도 있다 (비동기함수는 실패할 수도 있고 성공할 수도 있다)
        
        resolve( C의 반환값 )  -->  C가 성공을 했고, C라는 함수의 반환 값을 resolve 로 넘기면, C의 결과가 다음으로 넘어가면서 then 으로 넘어간다
                                                     C의 반환값이 then 으로 전달된다

    }).then(( C의 반환값 ) => F (F는 C를 필요로 한다))

    ==>  C 와 F 를 함께 비동기로 묶어서, A, B, D, E 가 끝난 후에 실행하도록 만들어준 것이다 (이게 promise 이다)
    ==>  async / await 도 이것과 똑같다  -->  async 는 함수 자체를 비동기로 만들어버리는 것 (다른 동기적 코드들을 await 으로 비동기처리 해줄 수 있다)

    ==>  비동기를 처리하는 함수인 Promise 는 한계가 존재한다  -->  then 이 계속 이어질 수 있는 한계가 존재한다 (그냥 보기 불편하다)
              이러한 한계 때문에 나온 것이 async / await 이다

--------------------------------------------------------------------------

) async / await

    -->  하나의 함수를 "비동기" 로 만들어버린다
    -->  장점은 await 을 사용해서 기다리게 할 수 있다  -->  await 기능은 Promise 의 then 과 똑같다고 보면 된다

    ex)
    A  -->  B  -->  C (비동기)  -->  D  -->  E  -->  F (비동기의 결과값이 필요함)
    ==>  원래는 C 와 F 를 Promise 로 감쌌다  -->  ex) Promise(C).then(F) 이런식으로 비동기 처리 했었다

    이런식으로 할 필요 없이 함수 앞에 async 를 붙이면 비동기 처리를 할 수 있다
    C 와 F 를 하나의 함수 안에 가두는 것이다  -->  그리고 그 함수 자체를 비동기로 만드는 것이다

    ex)
    async function () {
        const result = await C  -->  C 의 결과값이 나올 때까지 기다리는 것
        F(result)  -->  C 결과가 나오면 F 를 사용하는 것이다
    }
    ==>  이거 자체가 비동기 함수가 되는 것이다 (async 달아준 함수)

    ex)
    즉, async / await 을 사용하면 실행 순서는 이렇게 된다
    A  -->  B  -->  D  -->  E  -->  function( C / F )

----------------------------------------------------------------------------------------------------------------------------------------

    ==>  Promise 는 비동기로 만들어버리는 것이고, async / await 은 아예 함수 자체를 비동기로 만들어버리는 것이다

----------------------------------------------------------------------------------------------------------------------------------------

) fetch

    fetch 가 반환하는 값은 Response 타입이고, 비동기이다 (Promise 형태를 반환한다)

    사용 예시)
        const result = await fetch( "url" , { ... })
        const result = fetch.then()

        ==>  이렇게 두가지 방법으로 사용할 수 있는데, 이렇게 사용해야 fetch 의 결과값이 result 로 전달이 된다
                  await 으로 사용하려면 async 함수 안에서 사용해야한다

        ==>  fetch 의 반환값이 "Response" 타입이라고 했는데, 이 Response 는 우리가 사용할 수 없는 상태이다 (스트링 데이터 형태로 온다)
                  json 형태로 값을 바꿔주지 않으면 사용할 수 없다

        ==>  하지만 문제가 있다, 이 Response 를 json 형태로 바꾸는 이  "json()"  함수도  "비동기"  이다
                  그렇기에 결과가 result 에 담기는 것도 동기적 함수가 모두 끝나고 담긴다  -->  얘도 또 await 을 걸어줘야 한다

        ex)
        async function () {
        const result = await fetch
        const data = await result.json()  -->  data 선언한 것은 동기적 코드이지만, 필요로하는 값이비동기이기 때문에 "await" 을 걸어주는 것이다
                                                                  -->  json() 도 비동기함수이기에 await 을 걸어줘야한다
                                                                 -->  await 을 걸어주지 않으면, 모든 동기함수가 끝나고 실행을 한다
                                                                 -->  이렇게 해야 하는 이유는 json() 이 비동기기 때문 ( json() 이 친구도 Promise 를 반환한다 )
                                                                 -->  C의 결과값이 F에 필요한 경우와 같은 경우이다

        이렇게 await 을 걸어줘야 동기적으로 코드 짤 수 있다
        console.log( data )  -->  에러나지 않고 제대로 값 나온다
        }


        ) 결론은, 동기적 코드를 실행하는데 있어서 비동기 코드가 필요하다면, 이 동기적으로 실행하는 코드도 "비동기 처리" 해줘야 한다는 얘기이다
        )-->  비동기처리는 then 이나 await 으로 한다
        ) 이게 만약에 싫다고 한다면 그냥 then 을 계속 쓰면 된다  -->  ( fetch 가 Promise 라고 생각하면 된다 )
        ) Promise 로 말았다고 생각하면 편하다
        fetch(( result ) => result.json()).then(( data ) => console.log( data ))  -->  이렇게 쓰면 된다
                  ----------- C ------------          -------------------------- F ------------------------
                  ==>  이렇게 앞에가 C 인 것이고, 그 뒤에 C 를 필요로 하는 것이 F 인 것이다 (동기적 코드를 비동기처리 해준 것이다)


        ) await 과 then 을 섞어서 함께 쓸 수도 있다
        async function () {
        const data = await fetch.then(( result ) => result.json())
                                                             ------------ C -----------
        console.log( data )
        --------- F ---------
        }
        
----------------------------------------------------------------------------------------------------------------------------------------