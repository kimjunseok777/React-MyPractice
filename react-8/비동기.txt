

) 비동기란 무엇일까?

    -->  동기적 (순서대로 실행) 이지 않은 것을 뜻한다
    -->  비동기 코드는 동기적인 코드가 실행할 때, 같이 실행은 되지면 대기상태 (pending 상태) 가 되면서
            동기적인 코드가 모두 실행되고 난 후에 결과값 (reject, fulfilled ...) 을 반환한다 (성공 or 실패)
            (이벤트루프의 "que" 라는 저장소에 저장되어 대기하고 있다  -->  "콜스택" 으로 올라와서 실행이 된다)

    ==>  즉, 비동기는 동기와 같이 실행되는데, 동기적인 코드 모두 끝나고 결과를 반환한다

----------------------------------------------------------------------------------------------------------------------------------------

) 비동기는 왜 등장했는가?

    -->  자바스크립트는 싱글 스레드이다  -->  코드를 처리할 수 있는 일꾼이 딱 1명이다
    -->  자바스크립트는 일꾼이 하나니까, 여러 일을 동시에 해결하기 위해서 "비동기" 가 나오게 된 것이다

    ex)
    코드를 진행하는데 A -> B -> C -> D 라고 하는 함수들이 있다고 해보자

    A (1초)  -->  B (1초)  -->  C (3초)  -->  D (1초)  ==>  모두 실행하는데 6초가 걸린다

    A, B, D 를 실행하는 동안, C 를 함께 실행할 수 있다고 한다면 몇초가 걸릴까?  ==>  3초가 걸린다

    즉, 비동기라고 하는 것은 자바스크립트에서 시간이 많이 소요될 수 있는 함수들을 따로 빼서 (이벤트루프에 넘긴다) 따로 실행하는 것이다
    -->  동기적인 코드와 비동기적인 코드를 같이 실행시킬 수 있는 것이다  -->  시간을 감소시킬 수 있다 (먼저 화면에 보이는 것은 동깆적인 코드이다)

----------------------------------------------------------------------------------------------------------------------------------------

) 프론트엔드 개발자가 가장 많이 만나는 비동기해야하는 상황은 언제일까?
    
    1. 백엔드에서 데이터 받아올 때  -->  가장 많은 비중을 차지한다  ***
    2. 특정 시간 이후에 실행해야할 때  -->  ex) setTimeout, setInterval ... 등등
    3. 동기적인 코드가 모두 실행되고 나서 실행해야할 때

    fetch 또는 axios 가 대표적으로 백엔드와 데이터 통신을 할 때 가장 많이 사용하는 도구이다  ***
    -->  fetch, axios 는 비동기 처리가 된다  -->  동기적인 코드들이 실행될 때 같이 실행하고, 동기적인 코드가 모두 끝나면 결과를 실행한다

----------------------------------------------------------------------------------------------------------------------------------------

) 비동기 처리

    ex)
    A (1초)  -->  B (1초)  -->  C (3초 - 비동기)  -->  D (1초)  -->  E (1초)
    ==>  모두 실행되려면 몇초가 걸릴까?  -->  4초가 걸린다

    ==>  하지만, 동기적 함수이지만, 실행하기 위해 비동기 함수의 실행이 필요하다면 어떻게 될까?

    ex)
    A (1초)  -->  B (1초)  -->  C (3초 - 비동기)  -->  D (1초)  -->  E (1초)  -->  F (1초 - C가 필요하다)
    ==>  F 가 실행되려면 비동기인 C 가 필요하다
              C 가 밑으로 이동했다고 해보자 (비동기기에 같이 실행하니 보기 편하게 밑으로 이동시켜봊자)

    A (1초)  -->  B (1초)  -->  D (1초)  -->  E (1초)  -->  F (1초 - C가 필요하다)
    C (3초) -----------------------// C는 이때 실행이 끝난다  -->  이때 F는 C의 결과값을 사용할 수 있을까?  -->  사용할 수 없다, 에러뜬다

    ==>  비동기는 동기적 코드가 모두 실행되고 나서 실행되기에, C의 결과값은 F까지 끝나고 실행된다  -->  즉, F는 없다 (C 없기 때문에 오류뜬다)
    ==>  그래서 나오게 된 것이 Promise 와 async, await 이다  -->  C 와 F 를 한세트로 묶을 수 있다

    ex)
    A (1초)  -->  B (1초)  -->  D (1초)  -->  E (1초)  ==>  실행하는데 4초가 걸린다 (C가 필요하지 않기 때문에 에러가 나지 않는다)
    C (3초)  -->  F (1초)  ==>  A, B, D, E 가 끝나면 C 와 F 을 결과를 함께 보여준다 (비동기 처리)
    ==>  이렇게 동기 함수와 비동기 함수를 묶어서 사용할 수 있다 (C랑 F를 함께 비동기로 만들어버린 것이다)

----------------------------------------------------------------------------------------------------------------------------------------

) 대표적인 비동기처리 : promise , async / await

    -->  비동기가 아니지만, 비동기 다음에 실행해야 되는 친구들도 함께 비동기로 만들어줄 수 있다

--------------------------------------------------------------------------

) promise

    ex)
    new Promise(( reject, resolve ) => {
        //-->  reject 에다가 결과값이 반환되면 catch 로 이동하고, resolve 에다가 결과값이 반환되면 then 으로 이동한다 (콜백함수의 매개변수로 들어간다)
        // then  ->  이행
        // catch  ->  실패

        C  -->  C 는 실패할 수도 있고 성공할 수도 있다 (비동기함수는 실패할 수도 있고 성공할 수도 있다)
        
        resolve( C의 반환값 )  -->  C가 성공을 했고, C라는 함수의 반환 값을 resolve 로 넘기면, C의 결과가 다음으로 넘어가면서 then 으로 넘어간다
                                                     C의 반환값이 then 으로 전달된다

    }).then(( C의 반환값 ) => F(F는 C를 필요로 한다))

    ==>  C 와 F 를 함께 비동기로 묶어서, A, B, D, E 가 끝난 후에 실행하도록 만들어준 것이다 (이게 promise 이다)
    ==>  async / await 도 이것과 똑같다

    ==>  비동기를 처리하는 함수인 Promise 는 한계가 존재한다  -->  then 이 계속 이어질 수 있는 한계가 존재한다 (그냥 보기 불편하다)
              이러한 한계 때문에 나온 것이 async / await 이다

--------------------------------------------------------------------------

) async / await

    -->  하나의 함수를 "비동기" 로 만들어버린다
    -->  장점은 await 을 사용해서 기다리게 할 수 있다  -->  await 기능은 Promise 의 then 과 똑같다고 보면 된다

    ex)
    A  -->  B  -->  C (비동기)  -->  D  -->  E  -->  F (비동기의 결과값이 필요함)
    ==>  원래는 C 와 F 를 Promise 로 감쌌다  -->  ex) Promise(C).then(F) 이런식으로 비동기 처리 했었다

    이런식으로 할 필요 없이 함수 앞에 async 를 붙이면 비동기 처리를 할 수 있다
    C 와 F 를 하나의 함수 안에 가두는 것이다  -->  그리고 그 함수 자체를 비동기로 만드는 것이다

    ex)
    async function () {
        const result = await C  -->  C 의 결과값이 나올 때까지 기다리는 것
        F(result)  -->  C 결과가 나오면 F 를 사용하는 것이다
    }
    ==>  이거 자체가 비동기 함수가 되는 것이다 (async 달아준 함수)

    ex)
    즉, async / await 을 사용하면 실행 순서는 이렇게 된다
    A  -->  B  -->  D  -->  E  -->  function( C / F )

----------------------------------------------------------------------------------------------------------------------------------------