
react-4 수업은 "전역상태관리" 부터 시작한다

전역 상태 관리 (global state management)


    "지역변수" 와 "전역변수" 의 차이는 무엇일까?
    
        -->  지역변수 : 코드블럭 (특정 스코프) 내에서만 사용할 수 있는 것
        -->  전역변수 : 코드전체 (전역 스코프) 에서 사용할 수 있는 것


    ** 전역상태 ** 의 개념도 이와 같다

        -->  일반 상태 : 특정 컴포넌트 내에서만 사용하는 상태 (props 로 전달하면 하위 컴포넌트로 전달하는 것이 가능하다)  ===  지역 상태
        -->  전역 상태 : 컴포넌트 구분 없이 모든 컴포넌트에서 접근이 가능한 상태


-----------------------------------------------------------------------------------------------------------------------------------------------


    전역상태를 사용하는 이유 (면접 질문 필수로 나온다) ***


        ) 프롭스 드릴링 예방 :
                A  ->  ...  ->  D (A 컴포넌트의 하위의 하위의 하위인 D 컴포넌트로 어떠한 상태를 전달  -->  A - B - C - D)
                    
                -->  이러면 추적이 어려워진다
                -->  프롭스 드릴링이 계속 일어나면 이 상태가 어디서부터 시작됐는지 모르고, 단계가 굉장히 많아지기에 추적이 어려워진다
                -->  전달하는 과정에서도 상태가 변경될 수 있기 때문에 프롭스 드릴링이 많아질 수록 추적이 어려워진다

                ==>  즉, 전역상태는 프롭스 드릴링을 예방하기 위해 사용한다


        ) 불효 방지 :
                투두리스트 만들 때, Todo 컴포넌트가 자식들 때문에 자신에게 필요 없는 "todos" 배열의 상태를 갖고 있었다
                -->  자식 컴포넌트가 부모 컴포넌트에게 불효하고 있는 것이다

                ==>  부모가 자식 컴포넌트에 값을 전달하기 위해서 몰라도 되는 값을 알고 있을 때를 방지하기 위해 사용한다
                ==>  전역상태를 사용하면 Todo 컴포넌트가 "todos" 배열의 상태를 몰라도 되기 때문에 삭제할 수 있다


-----------------------------------------------------------------------------------------------------------------------------------------------


    전역상태를 관리하는 방법 (Context API , 라이브러리)


        ) Context API  -->  (현재 react-4 수업에서 사용할 방법이다)
                리액트에서 내장된 전역 상태 관리를 위한 빌트인 객체  -->  훅함수로 관리가 가능하다
                
                단점 :  - 보일러 코드가 많아진다  (사용하기 위해서 처음에 작성해야하는 코드가 많다)
                           - 리랜더링 최적화가 어렵다  (전역상태이다 보니 이 친구가 바뀌면 화면 전체가 리랜더링 되어버린다)
                           - 백엔드에서 받아온 데이터를 전역상태 관리하기 힘들다

                ==>  Context API 사용하는 것이 불편해서 나온 것이 밑의 라이브러리이다


        ) 라이브러리 (배워볼 라이브러리는 redux, recoil 이다)

                - redux
                        현재 사라져야하는 전역상태 관리 라이브러리 1위이다  (가장 초기에 나왔던 전역상태 라이브러리이기에 현재 사용하기 불편하다)
                        현재 시장에서 이전에 만들었던 프로젝트의 유지보수와 스텍을 맞추기 위해 사용하는 경우가 많다  (취업하게 되면 가장 많이 사용한다)
                        아직 redux 를 사용하는 회사가 많다  (가장 초기에 나왔기 때문)

                - mobx

                - recoil
                        리액트 (메타팀) 에서 직접 만든 라이브러리이다
                        최근에는 사용하는 경우가 적지만, 사용했던 프로젝트들이 다수 있고, 최근 유행하는 jotai 가 recoil 의 경량화 버전이다
                        즉, recoil 잘 사용하면 jotai 도 잘 사용할 수 있다

                - jotai
                        현재 가장 자주 사용되는 라이브러리

                - zustand
                        현재 가장 자주 사용되는 라이브러리


-----------------------------------------------------------------------------------------------------------------------------------------------


    전역상태관리 생성 순서

        1. 전역 상태를 저장하고 다룰 수 있는 공간을 생성  -->  createContext
            ex) 모든 컴포넌트들이 가져다가 사용할 수 있는 공간을 생성한 것
                  -->  다른 컴포넌트들이 여기서 만든 전역상태를 사용할 때, 이 공간을 useContext 로 가져다가 사용하는 것이다

        2. Provider (덮개) 를 생성해서 내가 전역 상태로 다루고 싶은 스코프의 최상위에 위치시킨다
            ex)  A, B 라는 두 컴포넌트에 전역상태를 관리하고 싶다면, 그 두개를 감싸고 있는 더 상위의 컴포넌트에 Provider 를 감싸주면 되는 것이다
            ex)  <Provider>
                        <Router />
                    </Provider>  -->  이런식으로 감싸주면 된다

        3. Provider 에 내가 전달 및 저장하고 싶은 값을 저장하면 된다
            ex)  <Provider  value={todos}>  -->  전역으로 사용하고 싶은 상태를 value 값으로 넣어준 것이다

        4. 컴포넌트에서 전역상태를 가져다가 사용할 때 useContext() 를 사용하면 된다
            -->  처음에 createContext 로 만들어준 공간을 사용할거란 의미이다


        순서 요약 )

            저장할 공간 생성  -->  어떤 컴포넌트에 값을 전달해줄 건지 Provider 로 범위를 정함
            -->  Provider 에 내가 전달하고 싶은 값 (상태) 을 전달 및 저장 (value 속성의 값으로 넣어준다)  -->  사용할 때는 useContext 로 사용하면 된다

            ) 순서는 todo.context.jsx 잘 공부해보자
            ) 전역상태관리는 사용하는 순서만 잘 알고 있어도 쉽게 사용할 수 있다

                -->  createContext  -->  Provider  -->  value  -->  useContext



===================================================================================================


** 경로 이동 : globalstate.txt  -->  context  -->  todo.context.jsx

                    ** 경로 이동 : todo.context.jsx  -->  App.js

                    -->  todo.context.jsx 작성 모두 했으면 App.js 로 가서 전역상태 만들어준 컴포넌트 (TodoProvider) 로 감싸주자
                            (Provider 로 감싸준 컴포넌트들은 이제 만들어준 전역상태를 공유할 수 있는 것이다)


===================================================================================================


** 경로 이동 : App.js  -->  components (addTodoModal.jsx , todoList.jsx)

                    -->  컴포넌트들로 가서 useContext 사용해서 전역 상태 사용해보자

                    -->  AddTodoModal 컴포넌트와 TodoList 컴포넌트가 같은 상태를 전역상태로 공유하고 있다는 것을 확인할 수 있다 (콘솔창 확인)


===================================================================================================


    구조 분해 할당 :
            객체  -->  객체를 분해해서 key 값으로 변수를 선언해줄 수 있는 것
            배열  -->  배열을 분해해서 index 순서대로 값을 가져와서 변수로 선언해줄 수 있는 것


===================================================================================================


** 경로 이동 : react-4-context-todo 폴더로 이동해주자 (hookstodo 리액트 파일 복사해올 거다  -->  투두리스트 일반 상태까지 진행된 투두리스트)

            -->  전역상태 개념 공부 모두 마쳤다면, 앞에서 만들었던 투두리스트에서 불효하는 상태를 전역상태로 바꿔보자
                    ( todo.jsx / todoList.jsx / oneTodo.jsx / todoList.jsx )


            ** 경로 이동 : store 폴더 만들어서 전역상태 저장공간 만들어주자  -->  todo.store.js


===================================================================================================

hookstodo 전역상태관리 모두 마치면 다시 globalstate.txt 로 경로 이동

===================================================================================================



useReducer (상태의 변화를 재사용하기 위해서 사용하는 것이다)
        
        -->  useReducer 는 dispatch 를 통해 상태를 변경시키는 요직이 작성되어있는 어떠한 "객체" 를 통째로 전달하는 것이다 (action 으로 전달)
                (dispatch 로 전달할 객체 안에 type, payload ... 등등 작성해서 전달해주면 된다)

        -->  밑의 useReducer 를 사용하는 두가지 이유를 알아보자


        ) 1. 복잡한 상태 변화를 재사용한다

                ex) state 를 변경하는 요직이 100줄이다  -->  똑같이 변경하는 곳이 3군데가 있다  -->  함수로 만드는 것이 편하다

                      하지만 이 useReducer 는 함수로 만드는 것 뿐만 아니라, 어떠한 객체 (action) 를 통째로 전달하여 상태 변화 로직을 재사용하는 것을 얘기한다
                      -->  컴포넌트가 아닌 일반 함수는 set 함수 사용이 어렵기 때문이다 (상태 훅 함수)
                      -->  다만, 커스텀 훅함수의 등장으로 사용도가 많이 떨어지는 편이다 (자주 사용하지는 않는다)


        ) 2. action 을 전달한다 (객체 전달)  -->  전달받은 action 에 따라서 실행시키는 요직이 달라지는 것이다

                ex) 사용자가 버튼을 누른다  -->  dispatch 라고 하는 매개체가 있다 (action 을 전달해주는 역할)
                      -->  dispatch 를 통해서 action 이라는 객체 전달  -->  action 을 전달받고 상태를 변화시킬 수 있는 것이 useReducer 이다

                      ==>  즉, 실행하는 이벤트로 dispatch 를 전달해주는 것이다 (요직은 이 dispatch를 전달받는 곳에 작성한다  -->  useReducer 로 실행시키는 함수이다)


-----------------------------------------------------------------------------------------------------------------------------------------------


useReducer 사용법 :

        먼저 상태 변화를 시켜줄 요직들이 들어가 있는 (재사용할 수 있는) 함수를 만들어주고 export 해줘야한다  -->  배개변수 순서는 ( state , action )
        -->  상태변화 요직은 switch 문으로 분기를 나눈다  -->  action 을 매개변수로 받는데, 이 action 의 키값으로 어떠한 상태 변화를 사용할지 정하는 것이다


        ) useReducer 생성 :

                export const 함수명 = ( 상태 , action ) => {
                        switch( action.key ) {

                                case "key 의 value 값" : return 상태 변경 요직 ~

                                case "key 의 value 값" : return 상태 변경 요직 ~  ...  이런식으로 case 로 분기 나눠서 상태 변경 요직들 작성해주면 된다

                                ...

                                default : return 상태
                        }
                }
                ==>  이렇게 전달 받은 action 에 따라서 실행시키는 상태 변화 요직이 달라지는 것이다 (재사용하기 편하다)


        ) useReducer 사용 : 상태를 useState 로 선언하지 않고 useReducer 로 선언한다

                ) 초기 선언 :
                        const [ 상태명 , dispatch ] = useReducer( 앞에서 생성한 함수 , [ 상태의 초기값 ] )  -->  이렇게 "useReducer" 로 상태를 선언한다
                                                                                                                                                                        (useState 로 선언하지 않는다)
                                                                                                                                                                        이 상태를 변경시키는 요직은 앞에 만들어준 함수에
                                                                                                                                                                        있는 것이아  -->  따로 set 함수 만들지 않는다

                ) 이벤트 등으로 실행할 함수 내에 작성 (상태변경) :
                        dispatch({
                                객체의 key 와 value 값 작성 ... (아래와 같이 작성)
                                type: ... ,
                                payload: { id: ... , name : ... }  ...  등과 같이 작성해주면 된다
                        })
                        ==>  이렇게 dispatch 안에 "action" 이라는 이름으로 전달할 객체를 작성해주면 된다


===================================================================================================


** 경로 이동 : globalstate.txt  -->  reducer  -->  user.reducer.js


** 경로 이동 : user.reducer.js  -->  components  -->  userList.jsx


===================================================================================================


** redux-2 들어가기 전 useReducer 복습

        useReducer 는 언제 사용해야할까?

                ) 상태의 변화를 재사용해야할 때

                        -->  상태 변경 로직이 너무 복잡해서 다시 짜기 힘들 때, 반복될 때 사용한다 (품질 좋은 코드를 만들려면 관리해야할 포인트를 줄여야한다)
                        -->  상태 변화를 중앙에서 집중적으로 관리하기 위해서 사용한다
                                상태는 컴포넌트 프롭스로 전달되며 관계가 복잡해지고 추적이 어려워질 수 있다  -->  이때 useReducer 를 사용하면 된다
                        -->  커스텀훅이 등장하면서 복ㅈ잡한 오직 재사용이 쉬어졌다  -->  그래서 이제는 그렇게 자주 사용하지는 않는다
                        -->  상태 변화의 분기가 많을 때 사용한다
                                ex) 녹음하는 기능 :
                                        대기 상태  -->  녹음 중 상태  -->  녹음 종료 상태  -->  다시 대기로 돌아가는 상태
                                        ==>  이렇게 어떠한 행위 (action) 에 따라서 type 이 변경된다면, useReducer 를 사용하면 좋다

                ==>  그냥 상태 상태 변화의 재사용이라고만 생각하면 "커스텀훅" 과 헷갈릴 수 있다 (커스텀 훅고 상태 변화를 재사용하기 위해서 사용할 수 있다)

                ==>  useReducer 는 상태변화를 중앙에서 집중적으로 관리하기 위해 사용하는데, 커스텀 훅과 다른 점이 있다면
                        상태 변화의 분기가 많을때 "switch" 문으로 구분할 수 있다는 장점이 있다

                ==>  상태를 바꿔야하는데, if문이 너무 많이 사용되어야 한다면, useReducer 를 사용하면 된다 (상태 변화에 대한 조건이 많을 때 사용)

                -----------------------------------------------------------------------------------------------------------------------------------------

                ==>  커스텀훅과 잘 구분해야 한다

                ) 커스텀훅을 사용하는 이유 :

                        -->  훅 함수가 포함된 함수를 재사용하기 위해서 사용한다

                        ==>  이와 다르게 useReducer 는 state 가 바뀌는 것을 모두 다 따로 reducer 로 분리해서 중앙 관리도 하고, 또 분기가 많이 쳐질 수 있는
                                  요직을 switch 문으로 쉽게 구현하기 위해서 사용한다


===================================================================================================


        ) 정리 :

                useReducer 는 상태 관리(변경)를 중앙에서 관리하고 분기에 따른 상태 변경을 쉽게하기 위해 사용하는 훅함수이며,

                커스텀 훅은 훅함수를 포함한 함수를 재사용하기 위해서 사용하는데, 이런 면에서 useReducer 와 비슷한 부분이 있다.

                단, 커스텀훅의 등장으로 useReducer 는 잘 사용하지 않는다.

                ) useReducer 는 분기가 많이 생성될 때 사용할 수 있다 ***  -->  이런 경우가 아니라면, 보통은 "커스텀훅" 을 쓰는 것이 더 좋다

                        ==>  그렇다면, 자주 사용하지 않는데, 왜 useReducer 를 배워야하는 것일까?  -->  "redux" 때문이다

                        ==>  ** redux : contextAPI 와 reducer 기반으로 만들어진 것이다  -->  reducer 를 이해하지 못하면, redux 를 이해하지 못한다 **

                ) redux : 중앙 집중 관리 전역상태 관리 도구이다


===================================================================================================