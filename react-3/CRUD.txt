
State Management - CRUD

    - Create  (생성)
    - Read  (조회)
    - Update  (갱신)
    - Delete  (삭제)

    먼저 CRUD 를 공부하기 위한 예시 상태이다
    state ex)

        const [ todos, setTodos ] = useState([
        {
            id: 1,
            title: "example-1",
            content: "content-1",
            state: false
        },
        {
            id: 2,
            title: "example-2",
            content: "content-2",
            state: true
        }
    ])

    todos 는 왜 상태여야하는가?

        -->  todo 가 추가되면 one-todo 가 사용자 화면에서 하나 증가 (레이아웃 변경)
        -->  todo 가 삭제되면 특정 one-todo 가 사용자 화면에서 삭제 (레이아웃 변경)
        -->  todo 가 상태가 변경되어 완료 (true / false) 로 변하면 사용자 화면에서 변경 (레이아웃 변경)

        ==>  이러한 점들이 있기에, todos 배열은 반드시 "상태 변수" 로 만들어야한다


-----------------------------------------------------------------------------------------------------------------------------------------------


- Create (생성)

        생성은 사용자가 입력한 todo 가 추가되는 것  -->  one-todo 가 하나 추가되는 형태이다
        
        최종으로 구현해야하는 코드는 무엇일까?  -->  setTodos ( todos.push ( newTodo ) )  -->  상태는 push 로 변경이 되지 않기 때문에 이렇게 하면 안된다

        -->  상태는 push 가 되면 안되기 때문에 "새로운 배열" 을 만들어 내야된다

        ...  -->  이렇게  "닷닷닷"  인 "전개연산자" 를 통해 오브젝트를 복사할 것이다  -->  전개연산자 : 내용물을 전개한다는 의미이다 (배열, 객체 모두 사용 가능하다)

        const object = [1, 2, 3]
        const temp_object = object
        console.log(temp_object)  //  [1, 2, 3]  -->  temp_object 는 object 가 바라보고 있는 주소와 똑같은 주소를 바라본다
        console.log(object == temp_object)  -->  주소가 같기에 "true" 가 나온다  -->  복사된게 아니라 같은 배열의 주소를 바라보고 있는 것이다 (복사본을 생성한 것이 아니다)

        복사본을 만들 때는 "전개 연산자" 를 통해서 안에 있는 내용물만 가져와야 한다

        전개 연산자 : . . .

            const object [1, 2, 3]
            const temp_object = [ ]  -->  새로운 배열을 선언한 것이다  -->  새로운 주소를 할당한다 (전에 만들었던 object 와는 다른 주소를 참조하고 있다)
                                              = [...object]  -->  이렇게 닷닷닷 object 해주면 이 배열 안에 object 배열의 내용물만 가져와서 전개한다는 의미이다

                                              ==>  즉, [...object] !== object 인게 되는 것이다 (아예 새로운 배열을 만들어준 것이다)  -->  temp_object !== object 이다
                                              ==>  주소가 달라진 형태로 내용물만 복사가 된 것이다

                                              ==>  전개 연산자  :  내용물만 가져와서 (복사해서) 전개시킨다는 의미이다


        ------------------------------------------------------------------------------------------------------------------------------------------


        최종적으로 구현해야하는 코드 :


            - 첫번째 방법 :

                    const temp_todos = [...todos]  -->  복사본 배열 생성 (전개연산자)

                    temp_todos.push(newTodo)  -->  이 친구는 상태가 아니라 일반 변수 (상태의 복사본) 이기 때문에 push 해줘도 된다

                    setTodos(temp_todos)  -->  이 push 해준 복사본 배열을 set 함수에 넣어줘서 상태를 변경시켜주면 되는 것이다 (복사본 배열을 변형시켜서, 원본과 바꿔치기 하는 것이다)

                    ==>  복사본을 만들고, 그 복사본에 push 로 내용물을 추가한 다음에, 그 복사본을 다시 셋팅하는 방법이다 (복사본 바꿔치기)


            - 두번째 방법 :

                    setTodos([...todos, newTodo])  -->  배열 안에 전개연산을 시키고, 배열의 마지막에 newTodo 를 추가하겠다는 의미이다

                    ==>  어차피 나는 마지막에 데이터를 붙이면 되는 것이기에, 전개연산 시키고, 배열 안에 컴마 찍고 추가할 데이터 적는 방법이다 (배열 마지막 인덱스로 추가되는 것이다)


            - 귀찮지만, 이렇게 구현해야하는 이유는 무엇일까? :

                    * todos 는 상태이기 때문에 push 할 수 없다  -->  직접적으로 push 로 데이터를 변경해서는 안된다, 무조건 복사본을 만들고 setTodos 로 바꿔야한다

                    * state의 불변성 때문이다
                        -->  todos 의 주소가 abc 이면, todos 가 push 되어 내용물이 추가되었다 하더라도 주소값이 똑같기 때문에 변화를 알 수 없다 (내용물 추가해도 주소는 계속 abc 이다)
                        -->  그렇기에, efgh 의 다른 주소값을 바라보는 todos 의 똑같은 배열이 필요한 것이다 (똑같은 내용물을 가졌지만, 다른 주소를 참조하고 있는 복사본 배열이 필요한 것이다)

                        ==>  객체나 배열은 "참조값" 이기에 값이 바뀌어도 재할당 하는 것이 아니라 값 자체가 변하기 때문에 이러한 과정을 거쳐야하는 것이다

                        ==>  기존의 주소값과, 변경하려는 주소값이 똑같으면 안된다  -->  주소값의 변경을 주려고 이러한 과정을 거치는 것이다

                        ==>  변경하려는데 주소값이 똑같다면, 리액트가 변화했다고 생각하지 않고 상태를 바꾸지 않는다

                        ==>  ** 주소값의 변화를 반.드.시 줘야한다 **  (주소값을 사용하는 참조타입인 "객체" , "배열" 일때 해당되는 애기이다)


                - 최종적으로 구현해야하는 코드 : setTodos([...todos, newTodo])  -->  복사본 배열 만들고, 마지막 요소로 newTodo 데이터 추가하는 방법

                        newTodo = {
                            id: shortId()  <--  랜덤 id 생성 (id는 겹치면 안된다)
                            title: 사용자의 입력값
                            content: 사용자의 입력값  -->  입력값들을 가져오는 것은 "form" 또는 "ref" 중에 정하면 된다
                            state: false  -->  완성이 아닌 미완성을 기본값으로 넣어야 하기 때문에 false 로 넣어주면 된다 (투두리스트)
                        }

                        ==>  id 와 state 는 정해져있고, newTodo 를 만들 때 필요한 값은 "title" 과 "content" 이다 (사용자의 입력값이다)

                        ==>  title, content 입력값 가져오는 방법  -->  event.target  -->  title.value , content.value (name 속성을 부여해줘서 가져오는 방법이다)


-----------------------------------------------------------------------------------------------------------------------------------------------


- Read (조회)

        조회는 todos 배열을 사용자 화면에 보여주기만 하면 되는 것이다  -->  그냥 map 돌리면 된다 (위의 예시 상태 배열 기준  -->  )

        todos.map((todo) =>
            <OneTodo todo={todo} />
        )

        ==>  props 로 전달해주는 이유는 todos 의 요소인 title, content, state 등을 전달해주기 위해서이다


-----------------------------------------------------------------------------------------------------------------------------------------------


- Update (갱신 , 수정)


        *  백엔드가 있을 때

                백엔드가 있다면, 추가에서 부터 달라진다  -->  id 나 state 만들 필요 없다
                -->  백엔드에게 title, content 주고, 백엔드에게 다시 데이터 달라고 하면 된다  -->  ...todos 같은 전개연산자도 할 필요가 없어진다

                ==>  title, content 백엔드에게 주고, 다시 백엔드에게 요청하고, setTodos() 하면 되는 것이다

                ==>  갱신 :  id (백엔드에서 전달한 식별 값) 랑 수정된 내용만 주면 된다


        *  백엔드가 없을 때

                todos 배열을 내가 직접 바꿔야한다  -->  따라서, todos 배열에서 내가 갱신하고 싶은 todo를 찾아내야 한다
                -->  해당 todo 의 속성 값을 바꾸면 된다

                배열에서 내가 원하는 조건에 맞는 요소를 찾는 방법 : find, findIndex (filter 는 "배열" 이 반환되기 때문에 아니다)  -->  제거할 때는 filter 가 사용된다 (걸러내는 역할)

                -->  todo 의 id 를 가지고 setTodos 를 할 것이다  -->  이때는 새로 "갱신" 된 todo 가 필요하다 (temp_todos)  -->  복사본 todo 를 넣을 것이다

                갱신 순서 )

                        const temp_todos = [...todos]  -->  주소값의 변화를 주기 위해 새로운 복사본 배열 생성

                        const selectTodo = temp_todos.find((todo) => todo.id === todoId)  -->  이 복사본 배열에서 todo 의 id 와 같은지 find 하는 것이다
                                                                                                                                                        (내가 수정버튼을 누른 리스트와 같은 id 값을 find로 찾는 것  -->  고유 식별 값)

                        selectTodo = {
                                ...selectTodo,  -->  selectTodo 의 기본 속성들이 복사가 된다 (title, content, state ... 등등 전개가 된다)
                                                          -->  여기서 selectTodo 는 내가 수정 버튼을 누른 todo.id 와 같은 id 를 가진 것이다 (복사본 배열이기에 id 값으로 일치하는 것 find 로 맞춰준 것)
                                title : selectTodo.title,
                                content : selectTodo.content,
                                state : selectTodo.state,

                                title: ... (수정된 타이틀)  -->  위에 selectTodo 전개연산자로 온 title 을 나중에 온 title 이 덮어 씨우는 것이다 (같은 key 는 중복해서 있을 수 없다)
                                (나중에 나온 속성 값이 덮어씌우기 때문에 순서가 매우 중요하다) ***
                        }

                        setTodos(temp_todos)

                                -->  객체도 전개연산자 사용하면 키랑 벨류 전개할 수 있다

                                input 으로는 뭐가 있어야할까?  -->  todoId, 수정된 내용  -->  여기서 todoId 는 고유 식별 값이다 (고유 식별 조건)


-----------------------------------------------------------------------------------------------------------------------------------------------


- Delete (삭제)

        특정 요소 혹은 특정 조건을 만족하는 요소들을 "제외한" 새로운 배열을 생성해서 상태를 변경하변 된다 (복사본으로 바꿔치기)

        * filter  -->  특정 조건에 맞는 요소를 제거한 상태로 새로운 배열을 반환한다 (새로운 배열 생성)  -->  자동으로 복사본 배열이 생성되는 것이다 (filter, map 등등)

        ex)

                const deleteTodos = todos.filter((todo) => todo.id !== todoId)  -->  todos 배열에서 id 가 todoId 인 것이 제외된 새로운 배열을 생성한 것이다
                                                                                                                                        (삭제 버튼 누른 목록의 id 와 같은 요소 제거한 새로운 배열 생성)
                                                                                                                               -->  todoId 가 아닌 것들만 모으겠다는 애기이다

                setTodos(deleteTodos)  -->  배열 바꿔치기

                -->  filter 를 사용하기에 복사본 만들 필요없이, 새로운 배열 자동 생성되기에 더 간단하다 (고차함수 filter 의 반환값이 새로운 배열이기 때문)
                -->  내가 필터링 하고 싶은 조건만 설정해주면 된다


-----------------------------------------------------------------------------------------------------------------------------------------------